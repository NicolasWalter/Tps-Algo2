function conMismasSanciones(in e:estr, in a:agente) --> res: conj(agente)
	res <-- siguiente(obtener(e.agentes, a).grupoSanciones)

function conKSanciones(in e:estr, in k:nat) --> res: conj(agente)
	if !e.huboNuevas then
		var nat i <-- BusquedaBin(e.buscoEnLog, k)
		res <-- e.buscoEnLog[i].grupoK
	else
		var itLista(datosK) itK <-- crearIt(e.agregoEn1)
		while haySiguiente(itK) do
			buscoEnLog[i] <-- siguiente(itK)
			avanzar(itK)
		endWhile
		var nat i <-- BusquedaBin(e.buscoEnLog, k)
		res <-- e.buscoEnLog[i].grupoK
	endIF
endFunction

function ingresarHippie (in h:Nombre, in p:Posicion, inout e:estr)
	definir(e.posCiviles,h,p)
	var itDicc(nombre,posicion) iterPos <-- definirRapido(e.posRapida,h,p)
	e.quienOcupa[p.X][p.Y] <-- <true,"hippie",crearIt(),agregar(e.hippies(<h,iterPos>))>
	var conj(posicion) Ps <-- vecinos(e.campus,p)
	var itConj(posicion) it <-- crearIt(Ps)			
	if esCapturable(e,p) then
		capturarHippie(e,p)
	else 
		while (haySiguiente(it)) do
				If ocupada(e.campus, siguiente(it)) v !e.quienOcupa[siguiente(it).X][siguiente(it).Y].ocupada?
					then avanzar(it)
				ELSE
					if esEstudiante(e,siguiente(it)) && esHippizable(e,siguiente(it)) then 
						Hippizar(e, siguiente(it))
						if esCapturable(e, siguiente(it)) then  capturarHippie(e, siguiente(it)) endIf
					else if esEstudiante(e, siguiente(it)) && esCapturable(e, siguiente(it)) then
							var itConj(posicion) itAg <-- vecinos(e.campus, siguiente(it))
							while (haySiguiente(itAg)) do
								if esAgente(e, sig(itAg)) then sancionar(e, sig(itAg)) endIf
								avanzar(itAg)
							endWhile
						else 
							if esHippie(e, siguiente(it)) && esCapturable(e, siguiente(it)) then
								capturarHippie(e,siguiente(it))
							endIf
						endIf
					endIf
				endIf				
				avanzar(it)
			endWhile

end Function 


function moverEstudiante (inout e:estr, in d:direccion, in s:estudiante) //FALTA EL CASO QUE SE VA A LA CASA LA CONCHA DE LA LORA
	var posicion actual <-- obtener(e.posCiviles, s)
	var posicion prx <-- proxPosicion(e.campus, d, actual)
	If(seFue?(e.campus,prx)) then
		borrar(e.posCiviles,s)
		var itConj(datosHoe) dat <-- copia(e.quienOcupa[actual.X][actual.Y].hayHoE)
		eliminarSiguiente(dat.posActual)
		eliminarSiguiente(dat)
		e.quienOcupa[actual.X][actual.Y] <-- <false,nada,crearIt(),crearIt()>
	Else
		var itConj(datosHoE) iterAHOI <-- copia(e.quienOcupa[actual.X][actual.Y].hayHoE)
		eliminarSiguiente(siguiente(iterAHOI).posActual)
		siguiente(iterAHOI).posActual <-- definirRapido(e.posRapida,s,prx)
		e.quienOcupa[prx.X][prx.Y] <-- <true,"estudiante",crearIt(),iterAHOI>
		e.quienOcupa [actual.X][actual.Y] <-- <false, "nada", nuevoIt(), nuevoIt()>
		definir(e.posCiviles, s, prx)
	
		var conj(posicion) vc <-- vecinos(e.campus, prx)
		var itConj(posicion) it <-- crearIt(vc)

		If ( esHippizable(e,prx) ) then 
			hippizar(e, prx)
			while (haySiguiente(it)) do
				If ocupada(e.campus, siguiente(it)) v !e.quienOcupa[siguiente(it).X][siguiente(it).Y].ocupada?
					then avanzar(it)
				ELSE
					if esEstudiante(e,siguiente(it)) && esHippizable(e,siguiente(it)) then 
						Hippizar(e, siguiente(it))
						if esCapturable(e, siguiente(it)) then  capturarHippie(e, siguiente(it)) endIf
					else if esEstudiante(e, siguiente(it)) && esCapturable(e, siguiente(it)) then
							var itConj(posicion) itAg <-- vecinos(e.campus, siguiente(it))
							while (haySiguiente(itAg)) do
								if esAgente(e, sig(itAg)) then sancionar(e, sig(itAg)) endIf
								avanzar(itAg)
							endWhile
						else 
							if esHippie(e, siguiente(it)) && esCapturable(e, siguiente(it)) then
								capturarHippie(e,siguiente(it))
							endIf
						endIf
					endIf
				endIf				
				avanzar(it)
			endWhile
		Else
			while (haySiguiente(it)) do
				if ocupada(e.campus, siguiente(it)) v !e.quienOcupa[siguiente(it).X][siguiente(it).Y].ocupada?
				then avanzar(it)
				else if esHippie(e,siguiente(it)) && esEstudiantizable(e,siguiente(it))
						then 	Estudiantizar(e, siguiente(it))
						else if esEstudiante(e, siguiente(it)) && esCapturable(e, siguiente(it))
								then var itConj(posicion) itAg2 <-- vecinos(e.campus, siguiente(it))
									while (haySiguiente(itAg2)) do
										if esAgente(e, sig(itAg2)) then sancionar(e, sig(itAg2)) endIf
										avanzar(itAg)
								else if esHippie(e, siguiente(it)) && esCapturable(e, siguiente(it))
									then capturarHippie(e,siguiente(it))
				avanzar(it)
			endWhile
		EndIf	
	EndIf
EndFunction

function moverAgente(inout e:estr, in a:agente)
	var int j <-- BusquedaBin(e.AgentesLog,a)
	var posicion actual <-- e.AgentesLog[j].pos
	var direccion d <-- proxPosicionA(e,a)
	var posicion prx <-- proxPosicion(e.campus, d, actual)
	var datosAg datAux <-- obtener(e.agentes,a)
	datAux.posActual <-- prx
	var itDicc(placa,datosAg) itA <-- copia(e.quienOcupa[actual.X][actual.Y].hayCana)
		e.quienOcupa[actual.X][actual.Y]<-- <false, nadie, nuevoIt(), nuevoIt()>
		e.quienOcupa[prx.X][prx.Y] <-- <true, agente, itA, nuevoIt()>
	var itConj(posicion) <-- crearIt(vecinos(e.campus, prx))
		while (haySiguiente(it)) do
			if ocupada(e.campus, siguiente(it)) v !e.quienOcupa[siguiente(it).X][siguiente(it).Y].ocupada?
			then avanzar(it)
			else if esEstudiante(e,siguiente(it)) && esCapturable(e,siguiente(it))
					then var itConj(posicion) itAg <-- vecinos(e.campus, siguiente(it))
								while (haySiguiente(itAg)) do
									if esAgente(e, sig(itAg)) then sancionar(e, sig(itAg)) endIf
									avanzar(itAg)
					else if esHippie(e,siguiente(it)) && esCapturable(e,siguiente(it))
						 then capturarHippie(e,siguiente(it)) 
						 end if
				end if
			end if
			avanzar(it)
		endWhile
		
		

function imoverHippie (inout e:estr, h:nombre)
	var posicion actual <-- obtener(e.posCiviles, h)
	var direccion d <-- proxPosicionH(e,h)
	var posicion prx <-- proxPosicion(e.campus, d, obtener(e.posCiviles,h))
	definir(e.posCiviles, h, prx)
	var itConj(nombre) itR <-- e.quienOcupa[actual.X][actual.Y].hayHoe
	eliminarSiguiente(siguiente(itR).posActual)
	siguiente(itR).posActual <-- definirRapido(e.posRapida, h, prx)
	e.QuienOcupa [prx.X][prx.Y] <-- <true, hippie, nuevoIt(), itR>
	e.QuienOcupa [actual.X][actual.Y] <-- <false, nadie, nuevoIt(), nuevoIt()>
	while (haySiguiente(it)) do
		if ocupada(e.campus, siguiente(it)) v !e.quienOcupa[siguiente(it).X][siguiente(it).Y].ocupada?
			then avanzar(it)
			else if esEstudiante(e,siguiente(it)) && esHippizable(e,siguiente(it))
					then Hippizar(e, siguiente(it))
						 if esCapturable(e, siguiente(it)) then  capturarHippie(e, siguiente(it)) endIf
					else if esEstudiante(e, siguiente(it)) && esCapturable(e, siguiente(it))
							then var itConj(posicion) itAg <-- vecinos(e.campus, siguiente(it))
								while (haySiguiente(itAg)) do
									if esAgente(e, sig(itAg)) then sancionar(e, sig(itAg)) endIf
									avanzar(itAg)
							else if esHippie(e, siguiente(it)) && esCapturable(e, siguiente(it))
								then capturarHippie(e,siguiente(it))
		avanzar(it)
endWhile

											
function esEstudiante (in e:estr, in p:posicion) --> res:bool
	
	res <-- e.quienOcupa[p.X][p.Y].queHay == estudiante
endFunction	
	
function esHippie (in e:estr, in p:posicion) --> res:bool
	
	res <-- e.quienOcupa[p.X][p.Y].queHay == hippie
endFunction

function esAgente (in e:estr, in p:posicion) --> res:bool
	
	res <-- e.quienOcupa[p.X][p.Y].queHay == agente	
endFunction

function Estudiantizar(inout e:Estr, p:posicion)
	var datosHoE dat <-- <Siguiente(e.quienOcupa[p.X][p.Y].hayHoE).ID, Siguiente(e.quienOcupa[p.X][p.Y].hayHoE).posActual> 
	eliminarSiguiente(e.quienOcupa[p.X][p.Y].hayHoE)
	var itConj(nombre) it <-- agregarRapido(e.estudiantes,dat)
	e.quienOcupa[p.X][p.Y]<-- <true, estudiante, crearIt(), it>
endFunction
	
function Hippizar(inout e:Estr, p:posicion)
	var datosHoE dat <-- <Siguiente(e.quienOcupa[p.X][p.Y].hayHoE).ID, Siguiente(e.quienOcupa[p.X][p.Y].hayHoE).posActual> 
	eliminarSiguiente(e.quienOcupa[p.X][p.Y].hayHoe)
	var itConj(nombre) it <-- agregarRapido(e.hippies,dat)
	e.quienOcupa[p.X][p.Y]<-- <true, hippie, crearIt(), it>	
endFunction

function esCapturable (in e:estr, in p:posicion) --> res:bool
	var itConj(posicion) it <-- crearIt(vecinos(e.campus,p))
	var nat Contador <-- 0
	var bool hayGuardia <-- false
	while (haySiguiente(it)) do
		if e.quienOcupa[p.X][p.Y].ocupada?
			then contador++
		endIf
		if e.quienOcupa[siguiente(it).X][siguiente(it).Y].quienOcupa == agente
			then hayGuardia <-- true
		endIf
		avanzar(it)
	endWhile
	res<--contador==4 && hayGuardia
endFunction	
	
function esHippizable (in e:estr, in p:posicion) --> res:bool
	var itConj(posicion) it <-- crear(vecinos(e.campus,p))
	var nat Contador <-- 0
	while (haySiguiente(it)) do
		if e.quienOcupa[siguiente(it).X][siguiente(it).Y].quienOcupa == hippie
		  	then contador++
		endIf
		avanzar(it)
	endWhile
	res <-- contador >= 2
endFunction	

function capturarHippie (inout e:estr, in p:posicion)
	var nombre n <-- siguiente(e.quienOcupa[p.X][p.Y].hayHoe).ID
	eliminarSiguiente(siguiente(e.quienOcupa[p.X][p.Y].hayHoe).posActual)
	eliminarSiguiente(e.quienOcupa[p.X][p.Y].hayHoe)
	borrar(n, e.posCiviles)
	e.quienOcupa[p.X][p.Y] <-- <false, nadie, crearIt(), crearIt()>
	var conj(posicion) v <-- vecinos(e.campus, p)	
	while haySiguiente(it) do
		if e.quienOcupa[siguiente(it).X][siguiente(it).Y].quienOcupa == agente
			then recompensar(e,siguiente(it))
		avanzar(it)
	endWhile
	
function todasOcupadas (in e:estr, in p:conj(posicion))--> res:bool
	var itConj(posicion) it <-- crear(p)
	var nat contador <-- 0
	while haySiguiente(it)
		if  e.quienOcupa[siguiente(it).X][siguiente(it).Y].ocupada?
			then contador++
		avanzar (it)
	endWhile

	res <-- contador == 4
	

function iIngresarEstudiante (in n:Nombre, in p:Posicion, inout e:estr){
	if(esHippizable(e,p)) then 
		if(esCapturable(e,p)) then
			var conj(posicion) v <-- vecinos(e.campus, p)
			var itConj(posicion) it <-- crearIt(v)
			while haySiguiente(it) do
				if e.quienOcupa[siguiente(it).X][siguiente(it).Y].queHay == "agente" then 
					recompensar(e,siguiente(it))
				avanzar(it)
			endWhile
		else 
			definir(e.posCiviles,n,p)
			var itDicc(nombre,posicion) iterPos <-- definirRapido(e.posRapida,n,p)
			e.quienOcupa[p.X][p.Y] <-- <true,"hippie",crearIt(),agregar(e.hippies(<n,iterPos>))>
			var conj(posicion) Ps <-- vecinos(e.campus, p)
			var itConj(posicion) it <-- crearIt(Ps)
			while (haySiguiente(it)) do
				if esEstudiante(e,siguiente(it)) && esHippizable(e,siguiente(it))	then
					Hippizar(e, siguiente(it))
					if (esCapturable(e, siguiente(it)) then  
					 	capturarHippie(e, siguiente(it)) endIf
				else 
					if esEstudiante(e, siguiente(it)) && esCapturable(e, siguiente(it))	then 
						var itConj(posicion) itAg <-- vecinos(e.campus, siguiente(it))
						    while (haySiguiente(itAg)) do
								if esAgente(e, sig(itAg)) then sancionar(e, sig(itAg)) endIf
								avanzar(itAg)
					else 
						if esHippie(e, siguiente(it)) && esCapturable(e, siguiente(it))
							then capturarHippie(&e,siguiente(it))
						endIf
				endIf
				avanzar(it)
			endWhile
	else
		definir(e.posCiviles,n,p)
		var itDicc(nombre,posicion) iterPos <-- definirRapido(e.posRapida,n,p)
		e.quienOcupa[p.X][p.Y] <-- <true,"estudiante",crearIt(),agregar(e.estudiantes(<n,iterPos>))>
		var conj(posicion) Ps <-- vecinos(e.campus,p)
		var itConj(posicion) it <-- crearIt(Ps)
		while (haySiguiente(it)) do
			if(esHippie(e,siguiente(it)) && esEstudiantizable(e,siguiente(it))) then
				Estudiantizar(e,siguiente(it))
			else
				if esEstudiante(e, siguiente(it)) && esCapturable(e, siguiente(it))	then 
						var itConj(posicion) itAg <-- vecinos(e.campus, siguiente(it))
						    while (haySiguiente(itAg)) do
								if esAgente(e, sig(itAg)) then sancionar(e, sig(itAg)) endIf
								avanzar(itAg)
				else 
						if esHippie(e, siguiente(it)) && esCapturable(e, siguiente(it))
							then capturarHippie(&e,siguiente(it))
						endIf
				endIf
			endIf
		endWhile
	endIF	
endFunction


function iRecompensar(inout e:estr, in a:posicion){
	var placa p <-- siguienteClave(quienOcupa[a.X][a.Y].hayCana)
	var datosAgente dat <-- obtener(e.agentes,p)
	dat.premios <-- dat.premios+1
	if(dat.premios > obtener(e.agentes,siguienteClave(e.masVigilante)).premios) then
		e.masVigilante <-- quienOcupa[a.X][a.Y].hayCana  else
		if(dat.premios == obtener(e.agentes,siguiente(e.masVigilante)).premios)) then
			if(p<siguienteClave(e.masVigilante)) then
				e.masVigilante<- quienOcupa[a.X][a.Y].hayCana 
			endIf
		endIf
	endIf
}
	
	
function iSancionar(inout e:estr, in a:posicion){
	var placa p <-- siguienteClave(quienOcupa[a.X][a.Y].hayCana)
	var datosAgente dat <-- obtener(e.agentes,p)
	dat.Qsanciones <-- dat.Qsanciones+1
	eliminarSiguiente(dat.grupoSanciones)
	avanzar(dat.verK)		
	if (Siguiente(dat.verK).K == dat.Qsanciones) then
		dat.grupoSanciones <- Agregar(siguiente(dat.verK).grupoK, p)
	else
		dat.grupoSanciones <- AgregarComoAnterior(dat.verK, <dat.Qsanciones, Agregar(Vacio(),p)>)
	endIf		
}













//////////              ALGORITMOS               LATEX                /////////////////

\begin{algorithm}\phantom{[H]}
\begin{algorithmic}[1]
\Function {\textsc{$i$Campus}}{\paramIn{e}{estr}}{$\disFlecha$ res : campus} \Comment{$\Ode{1}$}
  \State res $\gets$ e.campo
  
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}\phantom{[H]}
\begin{algorithmic}[1]
\Function {\textsc{$i$Estudiantes}}{\paramIn{e}{estr}}{$\disFlecha$ res : itConj(nombre)} \Comment{$\Ode{1}$}
	\State var itConj(nombre) it $\gets$ crearIt (e.estudiantes)
  	\State res $\gets$ it
  
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}\phantom{[H]}
\begin{algorithmic}[1]
\Function {\textsc{$i$Hippies}}{\paramIn{e}{estr}}{$\disFlecha$ res : itConj(nombre)} \Comment{$\Ode{1}$}
	\State var itConj(nombre) it $\gets$ crearIt (e.hippies)
  	\State res $\gets$ it
  
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}\phantom{[H]}
\begin{algorithmic}[1]
\Function {\textsc{$i$Agentes}}{\paramIn{e}{estr}}{$\disFlecha$ res : itConj(agente)} \Comment{$\Ode{1}$}
	\State var itDicc(placa,datosAgente) it $\gets$ crearIt (e.agentes)
  	\State res $\gets$ it
  
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}\phantom{[H]}
\begin{algorithmic}[1]
\Function {\textsc{$i$posEstudiantesYHippie}}{\paramIn{n}{nombre} \paramIn{e}{estr}}{$\disFlecha$ res : posicion} \Comment{$\Ode{\longitud{n_{m}}}$}
  	\State res $\gets$ obtener(n,e.posCiviles)
  
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}\phantom{[H]}
\begin{algorithmic}[1]
\Function {\textsc{$i$posAgente}}{\paramIn{a}{agente} \paramIn{e}{estr}}{$\disFlecha$ res : posicion} \Comment{$\Ode{1}(promedio)$}
  	\State res $\gets$ obtener(a,e.agentes).posActual
  
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}\phantom{[H]}
\begin{algorithmic}[1]
\Function {\textsc{$i$cantSanciones}}{\paramIn{a}{agente} \paramIn{e}{estr}}{$\disFlecha$ res : nat} \Comment{$\Ode{1}(promedio)$}
  	\State res $\gets$ obtener(a,e.agentes).Qsanciones
  
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}\phantom{[H]}
\begin{algorithmic}[1]
\Function {\textsc{$i$cantHippiesAtrapados}}{\paramIn{a}{agente} \paramIn{e}{estr}}{$\disFlecha$ res : nat} \Comment{$\Ode{1}(promedio)$}
  	\State res $\gets$ obtener(a,e.agentes).premios
  
\EndFunction
\end{algorithmic}
\end{algorithm}

