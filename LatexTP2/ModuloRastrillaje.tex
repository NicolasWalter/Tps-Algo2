% Diseño del tipo T
\newpage

% Diseño del Tipo
\disDisenio{Rastrillaje}
% La especificación
\disEspecificacion
\hspace*{\disSubSecMargen}Se usa el {\sc Tad CampusSeguro} especificado por la c\'atedra.

\disAspectosDeLaInterfaz

\disInterfaz

\disSeExplicaCon{CampusSeguro}

\disGenero{rastr}

\disOperaciones{b\'asicas de Rastrillaje}

\disDeclaraFuncion{Campus}{\paramIn{r}{rastr}}{res : campus}{true}{res $\igobs$ campus(r)}{\Ode{1}}{Devuelve el campus.}

\disDeclaraFuncion{Estudiantes}{\paramIn{r}{rastr}}{res : conj(nombre)}{true}{res $\igobs$ estudiantes(r)}{\Ode{1}}{Devuelve el conjunto de estudiantes presentes en el campus.}

\disDeclaraFuncion{Hippies}{\paramIn{r}{rastr}}{res : conj(nombre)}{true}{res $\igobs$ hippies(r)}{\Ode{1}}{Devuelve el conjunto de hippies presentes en el campus.}

\disDeclaraFuncion{Agentes}{\paramIn{r}{rastr}}{res : conj(agente)}{true}{res $\igobs$ agentes(r)}{\Ode{1}}{Devuelve el conjunto de agentes presentes en el campus.}

\disDeclaraFuncion{PosEstudianteYHippie}{\paramIn{r}{rastr}, \paramIn{id}{nombre}}{res : posicion}{id $\in$ (estudiantes(r) $\cup$ hippies(cs))}{res $\igobs$ posEstudianteYHippie(id,r)}{\Ode{1}}{Devuelve la posici\'on del estudiante/hippie pasado como par\'ametro.}

\disDeclaraFuncion{PosAgente}{\paramIn{r}{rastr}, \paramIn{a}{agente}}{res : posicion}{a $\in$ posAgente(a,r)}{res $\igobs$ posAgente(a,r)}{\Ode{1}}{Devuelve la posici\'on del agente pasado como par\'ametro.}

\disDeclaraFuncion{CantSanciones}{\paramIn{r}{rastr}, \paramIn{a}{agente}}{res : nat}{a $\in$ cantSanciones(a,r)}{res $\igobs$ cantSanciones(a,r)}{\Ode{1}}{Devuelve la cantidad de sanciones recibidas por el agente pasado como par\'ametro.}

\disDeclaraFuncion{CantHippiesAtrapados}{\paramIn{r}{rastr}, \paramIn{a}{agente}}{res : nat}{a $\in$ agentes(r)}{res $\igobs$ cantHippiesAtrapados(a,r)}{\Ode{1}}{Devuelve la cantidad de hippies atrapados por el agente pasado como par\'ametro.}

\disDeclaraFuncion{ComenzarRastrillaje}{\paramIn{c}{campus}, \paramIn{d}{dicc(agente,posicion)}}{res : rastr}{($\forall$ a : agente)(def?(a,d) $\impluego$ (posValida?(obtener(a,d))) $\land$ $\¬$ocupada?(obtener(a,d),c)) $\land$ ($\forall$ a, $a_{2}$ : agente)((def?(a,d) $\land$ def?($a_{2}$,d) $\land$ a $\not=a_{2}$) $\impluego$ obtener(a,d)$\not=$ obtener($a_{2}$,d))}{res $\igobs$ comenzarRastrillaje(c,d)}{\Ode{1}}{Crea un Rastrillaje.}

\disDeclaraFuncion{IngresarEstudiante}{\paramInOut{r}{rastr}, \paramIn{e}{nombre}, \paramIn{p}{posicion}}{}{r = $r_{0}$ $\land$ e $\notin$ (estudiantes(r)$\cup$hippies(r)) $\land$ esIngreso?(p,campus(r)) $\land$ $\¬$estaOcupada?(p,r)}{r $\igobs$ ingresarEstudiante(e,p,$r_{0}$)}{\Ode{1}}{Modifica el rastrillaje, ingresando un estudiante al campus.}

\disDeclaraFuncion{IngresarHippie}{\paramInOut{r}{rastr}, \paramIn{h}{nombre}, \paramIn{p}{posicion}}{}{r = $r_{0}$ $\land$ h $\notin$ (estudiantes(r)$\cup$hippies(r)) $\land$ esIngreso?(p,campus(r)) $\land$ $\¬$estaOcupada?(p,r)}{r $\igobs$ ingresarHippie(h,p,$r_{0}$)}{\Ode{1}}{Modifica el rastrillaje, ingresando un hippie al campus.}

\disDeclaraFuncion{MoverEstudiante}{\paramInOut{r}{rastr}, \paramIn{e}{nombre}, \paramIn{dir}{direccion}}{}{r = $r_{0}$ $\land$ e $\in$ estudiantes(r) $\land$ (seRetira(e,dir,r) $\lor$ (posValida?(proxPosicion(posEstudianteYHippie(e,r),dir,campus(r)),campus(r)) $\land$ $\¬$ estaOcupada?(proxPosicion(posEstudianteYHippie(e,r),dir,campus(r)),r)))}{r $\igobs$ moverEstudiante(e,d,$r_{0}$)}{\Ode{1}}{Modifica el rastrillaje, al mover un estudiante del campus.}

\disDeclaraFuncion{MoverHippie}{\paramInOut{r}{rastr}, \paramIn{h}{nombre}}{}{r = $r_{0}$ $\land$ h $\in$ hippies(r) $\land$ $\¬$todasOcupadas?(vecinos(posEstudianteYHippie(h,r),campus(r)),r) }{r $\igobs$ moverHippie(r,$r_{0}$)}{\Ode{1}}{Modifica el rastrillaje, al mover un hippie del campus.}

\disDeclaraFuncion{MoverAgente}{\paramInOut{r}{rastr}, \paramIn{a}{agente}}{}{r = $r_{0}$ $\land$ a $\in$ agentes(r) $\yluego$ cantSanciones(a,r) $\leq$ 3 $\land$ $\¬$todasOcupadas?(vecinos(posAgente(a,r),campus(r)),r)}{r $\igobs$ moverAgente(a,$r_{0}$)}{\Ode{1}}{Modifica el rastrillaje, al mover un agente del campus.}

\disDeclaraFuncion{MasVigilante}{\paramIn{r}{rastr}}{res : agente}{true}{res $\igobs$ masVigilante(r)}{\Ode{1}}{Devuelve el agente con mas capturas.}

\disDeclaraFuncion{ConKSanciones}{\paramIn{r}{rastr}, \paramIn{k}{nat}}{res : conj(agente)}{true}{res $\igobs$ conKSanciones(k,r)}{\Ode{1}}{Devuelve el agente con mas capturas.}

\disDeclaraFuncion{ConMismasSanciones}{\paramIn{r}{rastr}, \paramIn{a}{agente}}{res : conj(agente)}{a $\in$ agentes(r)}{res $\igobs$ conMismasSanciones(a,r)}{\Ode{1}}{Devuelve el conjunto de agentes con la misma cantidad de sanciones que a.}





\disPautasDeImplementacion

\disEstructuraDeRepresentacion

\disSeRepresentaCon{campus}{estr}
\disDondeEs{estr}{\disTuplaEstr{campus/campo, diccPromedio(agente ; datosAg)/agentes, arreglo(tupla(placa;posicion))/posAgentesLog, conjLineal(datosHoE)/hippies, conjLineal(datosHoE)/estudiantes, diccString(nombre;posicion)/posCiviles, diccLineal(nombre;posicion)/posRapida, vector(vector(datosPos))/quienOcupa, itConj(agente)/masVigilante, lista(datosK))/agregoEn1, vector(datosK)/buscoEnLog}}

\disDondeEs{datosAg}{\disTuplaEstr{nat/QSanciones, nat/premios, posicion/posActual, itConj(agente)/grupoSanciones, itLista(datosK)/verK}}

\disDondeEs{datosHoE}{\disTuplaEstr{nombre/ID, itDicc(nombre;posicion)/posActual}}

\disDondeEs{datosPos}{\disTuplaEstr{bool/ocupada?, clases/queHay, itDicc(agente)/hayCana, itConj(nombre)/hayHoE}}

\disDondeEs{clases}{enum\{``agente'',``estudiante'',``hippie'',``obstaculo'',``nada''\}}

\disDondeEs{datosK}{\disTuplaEstr{nat/K, conjLineal(agente)/grupoK}}

\disJustificacionDeLaEstructuraElegida
\newpage
\disInvarianteDeRepresentacion
\hspace*{\disSubSubSecMargen}\textbf{\textsf{Informal}}

\hspace*{\disSubSubSecMargen}
\begin{enumerate}
\setlength{\itemindent}{3em}
  \item El mapa debe tener tantas filas como indica la estructura, lo mismo con las columnas.

\end{enumerate}

\hspace*{\disSubSubSecMargen}\textbf{\textsf{Formal}}
\onehalfspace
\disRep{estr}{e}{$true$ $\Longleftrightarrow$ 
\\\hspace*{3.75em}(1)(2)(3)(4) ($\forall$ a,a2: Agente)(a $\neq$ a2 $\wedge$ definido?(a,e.agentes) $\wedge$ definido?(a2,e.agentes) \\ $\yluego$ PosValida(e.campo,obtener(a,e.agentes).PosActual) $\wedge$ PosValida(e.campo,obtener(a2,e.agentes).PosActual))) $\impluego$ \\ obtener(a,e.agentes).PosActual $\neq$ obtener(a2,e.agentes).PosActual \\ $\wedge $ (obtener(a,e.agentes).Qsanciones=siguiente(obtener(a,e.agentes).verK).K \\ $\wedge$ obtener(a,e.agentes).grupoSanciones=siguiente(obtener(a,e.agentes).verK).grupoK \\ $\wedge$ (a2 $\in$ obtener(a,e.agentes).grupoSanciones) $\Longleftrightarrow$ (obtener(a,e.agentes).Qsanciones = obtener(a2,e.agentes).Qsanciones) \\ $\wedge$ (5) TodasLasPlacas(e,e.posAgentesLog)= claves(e.agentes) \\ $\wedge$ (6) ($\forall$ a3:agente, t: tupla(agente,posicion))(t $\in$ e.posAgentesLog $\wedge$ a3= $\Pi_{1}$(t) $\yluego$ definido?(a3,e.agentes) $\impluego$ obtener(a3,e.agentes)= $\Pi_{2}$(t))
 \\ $\wedge$ enOrden(e.posAgentesLog) $\wedge$ enOrden(e.buscoEnLog)  \\ $\wedge$ (7) UnionConjuntos(e,e.lista)=claves(e.agentes) \\ $\wedge$ ($\forall$ h,h1:tupla(nombre,itDicc(nombre;posicion)))(h $\in$ e.hippies $\wedge$ h1 $\in$ e.hippies $\wedge$ $\Pi_{1}$(h) $\neq$ $\Pi_{1}$(h1)) $\impluego$ ($\Pi_{2}$(h) $\neq$ $\Pi_{2}$(h1)) \\
 $\wedge$ e.posCiviles=e.posRapida $\wedge$ ($\forall$ hi:nombre,e:nombre)((definido?(hi,e.posCiviles) $\wedge$ definido?(e,e.posCiviles)) $\impluego$ obtener(e,e.posCiviles) $\neq$ obtener(hi,e.posCiviles) \\$\wedge$ ($\forall$ a:agente, civ:nombre)(definido?(a,e.agentes) $\wedge$ definido?(civ,e.posCiviles)) \\ $\impluego$ (obtener(a,e.agentes) $\neq$ obtener(civ,e.posCiviles)) $\wedge$ (e.hippies $\cap$ e.estudiantes)= $\emptyset$ \\ $\wedge$ JuntarIDS(e.estudiantes)$\cup$JuntarIDS(e.hippies)=claves(e.posCiviles)) } 	
\disFuncionDeAbstraccion
\vspace*{-1em}
%\hspace*{\disSubSubSecMargen}{Texto}
\disAbs{estr}{e}{campus}{c}{\Big(filas(c) = e.filas $\land$ columnas(c) = e.columnas $\yluego$ ($\forall$ p : posicion)(p.X $\leq$ e.filas $\land$
\\\hspace*{3.75em} p.Y $\leq$ e.columnas $\impluego$ ocupada?(p,c) $\Leftrightarrow$ (e.mapa[f])[c]\Big) }


%\disFuncionDeAbsFuncionesAux


\newpage

\disAlgoritmos
%\hspace*{\disSubSubSecMargen}{Texto}
% HACK: SGA 28/05/2011. Para quitar el titulo Algorithm del caption \floatname{algorithm}{}
\floatname{algorithm}{}
% WARNING: SGA 27/05/2011. La opción [H] indica a LaTex que el algoritmo lo queremos AQUI!
% Ver 4.4.1 Placement of Algorithms de algorithms.pdf.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Campus}}{\paramIn{e}{estr}}{$\disFlecha$ res : campus} \Comment{$\Ode{1}$}
  \State res $\gets$ e.campo
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Estudiantes}}{\paramIn{e}{estr}}{$\disFlecha$ res : itConj(nombre)} \Comment{$\Ode{1}$}
  \State res $\gets$ crearIt (e.estudiantes)
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Hippies}}{\paramIn{e}{estr}}{$\disFlecha$ res : itConj(nombre)} \Comment{$\Ode{1}$}
  \State res $\gets$ crearIt (e.hippies)
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Agentes}}{\paramIn{e}{estr}}{$\disFlecha$ res : itConj(agente)} \Comment{$\Ode{1}$}
  \State res $\gets$ claves(e.agentes) 
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$posEstudiantesYHippie}}{\paramIn{n}{nombre} \paramIn{e}{estr}}{$\disFlecha$ res : posicion} \Comment{$\Ode{\longitud{n_{m}}}$}
    \State res $\gets$ obtener(n,e.posCiviles)
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$posAgente}}{\paramIn{a}{agente} \paramIn{e}{estr}}{$\disFlecha$ res : posicion} \Comment{$\Ode{1}(promedio)$}
    \State res $\gets$ obtener(a,e.agentes).posActual
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$cantSanciones}}{\paramIn{a}{agente} \paramIn{e}{estr}}{$\disFlecha$ res : nat} \Comment{$\Ode{1}(promedio)$}
    \State res $\gets$ obtener(a,e.agentes).Qsanciones
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$cantHippiesAtrapados}}{\paramIn{a}{agente} \paramIn{e}{estr}}{$\disFlecha$ res : nat} \Comment{$\Ode{1}(promedio)$}
    \State res $\gets$ obtener(a,e.agentes).premios
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$masVigilante}}{\paramIn{r}{rastr}}{$\disFlecha$ res : agente} \Comment{$\Ode{1}$}
    \State res $\gets$ siguiente(e.masVigilante)
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$conMismasSanciones}}{\paramIn{r}{rastr} \paramIn{a}{agente}}{$\disFlecha$ res : conj(agente)} \Comment{$\Ode{1}$}
    \State res $\gets$ siguiente(obtener(e.agentes,a).grupoSanciones)
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$conKSanciones}}{\paramIn{r}{rastr} \paramIn{k}{nat}}{$\disFlecha$ res : conj(agente)} \Comment{$\Ode{n}$ la primera vez, luego mientras no haya sanciones $\Ode{log n}$}
	\If {$\neg$e.huboNuevas} \Comment{$\Ode{1}$}
		 \State var nat i $\gets$ BusquedaBin(e.buscoEnLog, k) \Comment{$\Ode{log n}$}
		 \State res $\gets$ e.buscoEnLog$_{[i]}$.grupoK \Comment{$\Ode{1}$}
	\Else
		 \State var itLista(datosK) itK $\gets$ crearIt(e.agregoEn1) \Comment{$\Ode{1}$}
		 \While {haySiguiente(it)} \Comment{$\Ode{1}$}
		 	\State buscoEnLog $_{[i]}$ $\gets$ siguiente(itK) \Comment{$\Ode{1}$}
		 	\State avanzar(itK)
		 \EndWhile
		 \State var nat i $\gets$ BusquedaBin (e.buscoEnLog, k) \Comment{$\Ode{log n}$}
		 \State res $\gets$ e.buscoEnLog$_{[i]}$.grupoK \Comment{$\Ode{1}$}
		 \State e.hayNuevas $\gets$ false \Comment{$\Ode{1}$}
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$ingresarHippie}}{\paramInOut{r}{rastr} \paramIn{p}{posicion} \paramIn{h:nombre}}{} \Comment{$\Ode{\vert Nm \vert}$}
	\State definir(e.posCiviles, h,p) \Comment{$\Ode{\vert Nm \vert}$}
	\State var itDicc(nombre,posicion) iterPos $\gets$ definirRapido(e.posRapida,h,p) \Comment{$\Ode{1}$}
	\State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$ true, "hippie", crearIt(), agregarRapido(e.hippies,$<$h,iterPos$>$)$>$ \Comment{$\Ode{1}$}
	\State var conj(posicion) Ps $\gets$ vecinos(e.campus,p) \Comment{$\Ode{1}$}
	\State var itConj(posicion) $\gets$ crearIt(ps) \Comment{$\Ode{1}$}
	\If {esCapturable(e,p)} \Comment{$\Ode{1}$}
		\State capturarHippie(e,p) \Comment{$\Ode{\vert Nm \vert}$}
	\Else
		\While {haySiguiente(it)} \Comment{$\Ode{1}$}
			\If {ocupada(e.campus, siguiente(it)) $\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?} \Comment{$\Ode{1}$}
				\State avanzar(it) \Comment{$\Ode{1}$}
			\Else
				\If {esEstudiante(e,siguiente(it)) $\wedge$ esHippizable(e,siguiente(it))} \Comment{$\Ode{1}$}
					\State Hippizar(e, siguiente(it)) \Comment{$\Ode{1}$}
					\If {esCapturable(e,siguiente(it)}	 \Comment{$\Ode{1}$}
						\State capturarHippie(e,siguiente(it))  \Comment{$\Ode{\vert Nm \vert}$}
					\EndIf 
				\Else 
					\If {esEstudiante(e,siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
						\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
						\While {haySiguiente(itAg)} \Comment{$\Ode{1}$}
							\If {esAgente(siguiente(itAg)} \Comment{$\Ode{1}$}
								\State sancionar(e,siguiente(itAg)) \Comment{$\Ode{1}$}
							\EndIf
							\State avanzar(itAg)
						\EndWhile
   					 \EndIf
				\EndIf
			\EndIf
			\State avanzar(it)
		\EndWhile
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$moverEstudiante}}{\paramInOut{r}{rastr}, \paramIn{d}{direccion}, \paramIn{s}{estudiante}} \Comment{$\Ode{\vert Nm \vert}$}
	\State var posicion actual $\gets$ obtener(e.posCiviles,s)  \Comment{$\Ode{1}$}
	\State var posicion prx $\gets$ proxPosicion(e.campus, d, actual)  \Comment{$\Ode{1}$}
	\If {seFue?(e.campus,actual, prx)}
		\State borrar(e.posCiviles, s) \Comment{$\Ode{\vert Nm \vert}$}
		\State var itConj(datosHoE) dat $\gets$ copia(e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$.hayHoE) \Comment{$\Ode{1}$}
		\State eliminarSiguiente(dat, posActual) \Comment{$\Ode{1}$}
		\State eliminarSiguiente(dat) \Comment{$\Ode{1}$}
		\State e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$ $\gets$ $<$ false, "nada", crearIt(), crearIt() $>$ \Comment{$\Ode{1}$}
	\Else
		\State var itConj(datosHoE) iterAHOI $\gets$ copia(e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$.hayHoE) \Comment{$\Ode{1}$}
		\State eliminarSiguiente(siguiente(iterAHOI).posActual) \Comment{$\Ode{1}$}
		\State siguiente(iterAHOI).posActual $\gets$ definirRapido(e.posRapida,s,prx) \Comment{$\Ode{1}$}
		\State e.quienOcupa$_{[prx.X]}$ $_{[prx.Y]}$ $\gets$ $<$true, $"$estudiante$"$, crearIt(), iterAHOI$>$ \Comment{$\Ode{1}$}
		\State e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$ $\gets$ $<$false, "nada", crearIt(), crearIt()$>$ \Comment{$\Ode{1}$}
		\State definir(e.posCiviles, s, prx) \COmment{$\Ode{\vert Nm \vert}$}
		\State var conj(posicion) vc $\gets$ vecinos(e.campus, prx) \Comment{$\Ode{1}$}
		\State var itConj(posicion) it $\gets$ crearIt(vc) \Comment{$\Ode{1}$}
		
		\If {esHippizable(e,prx)} \Comment{$\Ode{1}$}
			\State hippizar(e, prx) \Comment{$\Ode{1}$}
			\While {haySiguiente(it} \Comment{$\Ode{1}$}
				\If {ocupada(e.campus, siguiente(it)) $\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?}
					\State avanzar(it)
				\Else \If {esEstudiante(e,siguiente(it)) $\wedge$ esHippizable(e,siguiente(it))} \Comment{$\Ode{1}$}
						 \State Hippizar(e, siguiente(it))  \Comment{$\Ode{1}$}
						 \If {esCapturable(e, siguiente(it))}  \Comment{$\Ode{1}$}
						 	\State capturarHippie(e,siguiente(it))  \Comment{$\Ode{\vert Nm \vert}$}
						 \EndIf
					  \Else \If {esEstudiante(e,siguiente(it) $\wedge$ esCapturable(e,siguiente(it)} \Comment{$\Ode{1}$}
					  			\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
					  			\While {haySiguiente(itAg)} \Comment{$\Ode{1}$}
					  				\If {esAgente(e,siguiente(itAg)} \Comment{$\Ode{1}$}
					  					\State sancionar(e,siguiente(itAg)) \Comment{$\Ode{1}$}
					  				\EndIf
					  			\State avanzar(itAg)
					  			\EndWhile
					  		\Else
					  			\If {esHippie(e,siguiente(it)) $\wedge$ esCapturable(s,siguiente(it))} \Comment{$\Ode{1}$}
					  				\State capturarHippie(e,siguiente(it))  \Comment{$\Ode{\vert Nm \vert}$}
					  			\EndIf	
					  		\EndIf
					  	\EndIf
					\EndIf
			\EndWhile
		\Else
			\While {haySiguiente(it)}
			\If {ocupada(e.campus, siguiente(it))$\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?} \Comment{$\Ode{1}$}
					\State avanzar(it)
				\Else
					\If {esHippie(e, siguiente(it)) $\wedge$ esEstudiantizable(e,siguiente(it))} \Comment{$\Ode{1}$}
						\State Estudiantizar(e, siguiente(it)) \Comment{$\Ode{1}$}
					\Else
						\If {esEstudiante(e,siguiente(it)) $\wedge$ esCapturable(e, siguiente(it))} \Comment{$\Ode{1}$}
							\State var itConj(posicion) itAg2 $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
							\While {haySiguiente(itAg2)} \Comment{$\Ode{1}$}
								\If {esAgente(e,siguiente(itAg2))} \Comment{$\Ode{1}$}
									\State sancionar(e,siguiente(itAg2)) \Comment{$\Ode{1}$}
								\EndIf
								\State avanzar(itAg2)
							\EndWhile
							\newpage
						\Else
							\If {esHippie(e, siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
								\State capturarHippie(e, siguiente(it))  \Comment{$\Ode{\vert Nm \vert}$}
							\EndIf
						\EndIf
					\EndIf
				\EndIf
				\State avanzar(it)
			\EndWhile
		\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$moverAgente}}{\paramInOut{r}{rastr} \paramIn{a}{agente}}{} \Comment{$\Ode{\vert Nm \vert}$ $+$ $\Ode{log Na}$ $+$ $\Ode{Ne}$}
    \State var nat j $\gets$ BusquedaBin(e.AgentesLog,a) \Comment{$\Ode{log n}$}
    \State var posicion actual $\gets$ e.AgentesLog$_{[j]}$ \Comment{$\Ode{1}$}
    \State var direccion d $\gets$ proxPosicionA(e,a) \Comment{$\Ode{Ne}$}
    \State var posicion prx $\gets$ proxPosicion(e.campus, d, actual) \Comment{$\Ode{1}$}
    \State var datosAg datAux $\gets$ obtener(e.agentes, a) \Comment{$\Ode{1}$}
    \State datAux.posActual $\gets$ prx \Comment{$\Ode{1}$}
    \State var itDicc(placa,datosAg) itA $\gets$ copia(e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$.hayCana) \Comment{$\Ode{1}$}
    \State e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$ $\gets$ $<$false, "nadie", crearIt(), crearIt()$>$ \Comment{$\Ode{1}$}
    \State e.quienOcupa$_{[prx.X]}$ $_{[prx.Y]}$ $\gets$ $<$true, $"$agente", itA, crearIt()$>$ \Comment{$\Ode{1}$}
    \State var itConj(posicion) $\gets$ crearIt(vecinos(e.campus, prx)) \Comment{$\Ode{1}$}
    \While {haySiguiente(it)} \Comment{$\Ode{1}$}
    	\If {ocupada(e.campus, siguiente(it)) $\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?}
    		\State avanzar(it)
    	\Else
    		\If {esEstudiante(e, siguiente(it)) $\wedge$ esCapturable(e, siguiente(it))} \Comment{$\Ode{1}$}
    			\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
    			\While {haySiguiente(itAg)}  \Comment{$\Ode{1}$}
    				\If {esAgente(e,siguiente(itAg))}  \Comment{$\Ode{1}$}
    					\State sancionar(e, siguiente(itAg))  \Comment{$\Ode{1}$}
    				\EndIf
	    			\State avanzar(itAg)
    			\EndWhile
    		\Else
    			\If {esHippie(e,siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))}  \Comment{$\Ode{1}$}
    				\State capturarHippie(e, siguiente(it))  \Comment $\Ode{\vert Nm \vert}$
    			\EndIf
    		\EndIf
    	\EndIf	
    	\State avanzar(it)
    \EndWhile
    
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$esEstudiante}}{\paramIn{r}{rastr} \paramIn{p}{posicion}}{$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
    \State res $\gets$ e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $==$ "estudiante"
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$esHippie}}{\paramIn{r}{rastr} \paramIn{p}{posicion}}{$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
    \State res $\gets$ e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $==$ "hippie"
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$esAgente}}{\paramIn{r}{rastr} \paramIn{p}{posicion}}{$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
    \State res $\gets$ e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $==$ "agente"
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Estudiantizar}}{\paramInOut{r}{rastr} \paramIn{p}{posicion}}{} \Comment{$\Ode{1}$}
    \State var datosHoE dat $\gets$ $<$Siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoE).ID, Siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoe).posActual$>$ \Comment{$\Ode{1}$}
    \State eliminarSiguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoe) \Comment{$\Ode{1}$}
    \State var itConj(nombre) it $\gets$ agregarRapido(e.estudiantes, dat) \Comment{$\Ode{1}$}
    \State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$true, "estudiante", crearIt(), it$>$ \Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Hippizar}}{\paramInOut{r}{rastr} \paramIn{p}{posicion}}{} \Comment{$\Ode{1}$}
    \State var datosHoE dat $\gets$ $<$Siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoE).ID, Siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoe).posActual$>$ \Comment{$\Ode{1}$}
    \State eliminarSiguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoe) \Comment{$\Ode{1}$}
    \State var itConj(nombre) it $\gets$ agregarRapido(e.hippies, dat) \Comment{$\Ode{1}$}
    \State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$true, "hippie", crearIt(), it$>$ \Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$esCapturable}}{\paramIn{r}{rastr} \paramIn{p}{posicion}}{$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
    \State var itConj(posicion) it $\gets$ crearIt(vecinos(e.campus, p)) \Comment{$\Ode{1}$}        	\State var nat Contador $\gets$ 0 \Comment{$\Ode{1}$}
    \State bool hayGuardia $\gets$ false \Comment{$\Ode{1}$}
	\While {haySiguiente(it)}
		\If {e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.ocupada?} \Comment{$\Ode{1}$}
			\State contador$+$ $+$ \Comment{$\Ode{1}$}
		\EndIf
		\If {e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.quienOcupa== "agente" } \Comment{$\Ode{1}$}
   			\State  hayGuardia $\gets$ true \Comment{$\Ode{1}$}
   		\EndIF
   		\State avanzar(it)
   	\EndWhile
   	\State res $\gets$ contador == 4 $\wedge$ hayGuardia
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Hippizar}}{\paramInOut{r}{rastr} \paramIn{p}{posicion}}{$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
    \State var itConj(posicion) it $\gets$ crearIt(vecinos(e.campus, p)) \Comment{$\Ode{1}$}        	\State var nat Contador $\gets$ 0 \Comment{$\Ode{1}$}
    \While {haySiguiente(it)} \Comment{$\Ode{1}$}
    	\If {e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.quienOcupa == "hippie"} \Comment{$\Ode{1}$}
    		\State contador $+$ $+$ \Comment{$\Ode{1}$}
    	\EndIf
    	\State avanzar(it)
     \EndWhile
    \State res $\gets$ contador $\geqslant$ 2 \Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$capturarHippie}}{\paramInOut{r}{rastr} \paramIn{p}{posicion}}{} \Comment{$\Ode{\vert Nm \vert}$}
    \State var nombre n $\gets$ siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoE).ID \Comment{$\Ode{1}$}
    \State eliminarSiguiente(siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoE).posActual \Comment{$\Ode{1}$}
    \State eliminarSiguiente(siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoE) \Comment{$\Ode{1}$}
    \State borrar(n, e.posCiviles) \Comment{$\Ode{\vert Nm \vert}$}
	\State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$false, nadie, crearIt(), crearIt() $>$ \Comment{$\Ode{1}$}
	 \While {haySiguiente(it)} \Comment{$\Ode{1}$}
    	\If {e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.quienOcupa == "agente"} \Comment{$\Ode{1}$}
    		\State recompensar(e, siguiente(it)) \Comment{$\Ode{1}$}
    	\EndIf
    	\State avanzar(it)
     \EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$todasOcupadas}}{\paramIn{r}{rastr}, \paramIn{p}{conj(posicion)}}{$\disFlechas$ res:bool} \Comment{$\Ode{1}$}
	\State var itConj(posicion) it $\gets$ crearIt(p) \Comment{$\Ode{1}$}
	\State var contador $\gets$ 0 \Comment{$\Ode{1}$}
	\While {haySiguiente(it)}
		\If {e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?} \Comment{$\Ode{1}$}
		    \State contador $+$ $+$ \Comment{$\Ode{1}$}
		\EndIf
	\EndWhile
	\State res $\gets$ contador == 4
\EndFunction
\end{algorithmic}
\end{algorithm}
	
\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$ingresarEstudiante}}{\paramInOut {r}{rastr}, \paramIn {n}{nombre}, \paramIn {p}{posicion}} \Comment{$\Ode{\mid Nm \mid}$}
\If {esHippizable(e,p)} \Comment{$\Ode{1}$}
		\If {esCapturable(e,p)} \Comment{$\Ode{1}$}
			\State var conj(posicion) v $\gets$ vecinos(e.campus, p) \Comment{$\Ode{1}$}
			\State var itConj(posicion) it $\gets$ crearIt(v) \Comment{$\Ode{1}$}
			\While {haySiguiente(it)}
				\If {e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.queHay == "agente"} \Comment{$\Ode{1}$}
					\State recompensar(e, siguiente(it)) \Comment{$\Ode{1}$}
				\EndIf
				\State avanzar(it)
			\EndWhile
		\Else
			\State definir(e.posCiviles, n, p)  \Comment{$\Ode{\mid Nm \mid}$}
			\State var itDicc(nombre, posicion) iterPos $\gets$ definirRapido(e.posRapida,n,p) \Comment{$\Ode{1}$}
			\State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$ true,"hippie",crearIt(), agregarRapido(e.hippies,$<$n,iterPos$>$)$>$ \Comment{$\Ode{1}$}
			\State var conj(posicion) Ps $\gets$ vecinos(e.campus, p) \Comment{$\Ode{1}$}
			\State var itConj(posicion) it $\gets$ crearIt(Ps) \Comment{$\Ode{1}$}
			\While {haySiguiente(it)} 
				\If {esEstudiante(e,siguiente(it)) $\wedge$ esHippizable(e,siguiente(it))} \Comment{$\Ode{1}$}
					\State Hippizar(e, siguiente(it)) \Comment{$\Ode{1}$}
					\If {esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
						\State capturarHippie(e,siguiente(it)) \Comment{$\Ode{\mid Nm \mid}$}
					\EndIf
				\Else
					\If {esEstudiante(e,siguiente(it)) $\wedge$ esCapturable(e, siguiente(it))} \Comment{$\Ode{1}$}
						\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
						\While {haySiguiente(itAg)}  \Comment{$\Ode{1}$}
							\If {esAgente(e, siguiente(itAg))} \Comment{$\Ode{1}$}
								\State sancionar(e,siguiente(itAg)) \Comment{$\Ode{1}$}
							\EndIf
							\State avanzar(itAg)
						\EndWhile
					\Else
						\If {esHippie(e, siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))}  \Comment{$\Ode{1}$}
							\State capturarHippie(e,siguiente(it)) \Comment{$\Ode{\mid Nm \mid}$}
						\EndIf
					\EndIf
				  \EndIf
					\State avanzar(it)
				\EndWhile
			  \EndIf
			\Else
				\State definir(e.posCiviles, n, p)  \Comment{$\Ode{\mid Nm \mid}$}
				\State var itDicc(nombre, posicion) iterPos $\gets$ definirRapido(e.posRapida, n, p)  \Comment{$\Ode{1}$}
				\State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$ true,"estudiante",crearIt(), agregarRapido(e.estudiantes,$<$n,iterPos$>$)$>$
				\State var conj(posicion) Ps $\gets$ vecinos(e.campus, p) \Comment{$\Ode{1}$}
				\State var itConj(posicion) it $\gets$ crearIt(ps) \Comment{$\Ode{1}$}
				\While {haySiguiente(it)}
					\If {esHippie(e,siguiente(it)) $\wedge$ esEstudiantizable(e,siguiente(it))} \Comment{$\Ode{1}$}
						\State Estudiantizar(e,siguiente(it)) \Comment{$\Ode{1}$}
					\Else
						\If {esEstudiante(e,siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
							\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
							\While {haySiguiente(itAg)}
								\If {esAgente(e,siguiente(itAg))} \Comment{$\Ode{1}$}
									\State Sancionar(e,siguiente(itAg)) \Comment{$\Ode{1}$}
								\EndIf
								\State avanzar(itAg)
							\EndWhile
						\Else
							\If {esHippie(e,siguiente(it) $\wedge$ esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
								\State	capturarHippie(e,siguiente(it))  \Comment{$\Ode{\mid Nm \mid}$}
							\EndIf
						\EndIf
					\EndIf
				\EndWhile
			\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}
\Function
				
	

\begin{algorithmic}
\begin{algorithm}
\Function{\textsc{$i$Recompensar}}{\paramInOut{r}{rastr}, \paramIn{a}{posicion}}{} \Comment{$\Ode{1}$}
	\State var placa p $\gets$ siguienteClave(quienOcupa$_{[a.X]}$ $_{[a.Y]}$.hayCana \Comment{$\Ode{1}$}
	\State var datosAgente dat $\gets$ obtener(e.agentes,p) \Comment{$\Ode{1}$}
	\State dat.premios $\gets$ dat.premios$+$1 \Comment{$\Ode{1}$}
	\If {dat.premios > obtener(e.agentes, siguienteClave(e.masVigilante)).premios} \Comment{$\Ode{1}$}
		\State e.masVigilante $\gets$ quienOcupa$_{[a.X]}$ $_{[a.Y]}$.hayCana \Comment{$\Ode{1}$}
	\Else
		\If {dat.premios == obtener(e.agentes, siuienteClave(e.masVigilante)).premios} \Comment{$\Ode{1}$}
			\If {p < siguienteClave(e.masVigilante))} \Comment{$\Ode{1}$}
				\State e.masVigilante $\gets$ quienOcupa$_{[a.X]}$ $_{[a.Y]}$.hayCana \Comment{$\Ode{1}$}
			\EndIf
		\EndIf
	\EndIf
\EndFunction
\end{algorithm}
\end{algorithmic}

\begin{algorithmic}
\begin{algorithm}
\Function{\textsc{$i$Sancionar}}{\paramInOut{r}{rastr}, \paramIn{a}{posicion}}{} \Comment{$\Ode{1}$}
	\State var placa p $\gets$ siguienteClave(quienOcupa$_{[a.X]}$ $_{[a.Y]}$.hayCana \Comment{$\Ode{1}$}
	\State var datosAgente dat $\gets$ obtener(e.agentes,p) \Comment{$\Ode{1}$}
	\State dat.Qsanciones $\gets$ dat.Qsanciones$+$1 \Comment{$\Ode{1}$}
	\State eliminarSiguiente(dat.grupoSanciones)  \Comment{$\Ode{1}$}
	\State avanzar(dat.verK)  \Comment{$\Ode{1}$}
	\State e.hayNuevas $\gets$ true  \Comment{$\Ode{1}$}
	\If {Siguiente(dat.verK).K == dat.Qsanciones} \Comment{$\Ode{1}$}
		\State dat.grupoSanciones $\gets$ Agregar(siguiente(dat.verK).grupoK, p)  \Comment{$\Ode{1}$}
	\Else
		\State dat.grupoSanciones $\gets$ AgregarComoAnterior(dat.verK, <dat.Qsanciones,Agregar(Vacio(),p)>) \Comment{$\Ode{1}$}
	\EndIf
\EndFunction
\end{algorithm}
\end{algorithmic}