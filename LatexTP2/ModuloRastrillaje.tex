% Diseño del tipo T
\newpage

% Diseño del Tipo
\disDisenio{Rastrillaje}
% La especificación
\disEspecificacion
\hspace*{\disSubSecMargen}Se usa el {\sc Tad CampusSeguro} especificado por la c\'atedra.

\disAspectosDeLaInterfaz

\disInterfaz

\disSeExplicaCon{CampusSeguro}

\disGenero{rastr}

\disOperaciones{b\'asicas de Rastrillaje}

\disDeclaraFuncion{Campus}{\paramIn{r}{rastr}}{res : campus}{true}{res $\igobs$ campus(r)}{\Ode{1}}{Devuelve el campus.}

\disDeclaraFuncion{Estudiantes}{\paramIn{r}{rastr}}{res : conj(nombre)}{true}{res $\igobs$ estudiantes(r)}{\Ode{1}}{Devuelve el conjunto de estudiantes presentes en el campus.}

\disDeclaraFuncion{Hippies}{\paramIn{r}{rastr}}{res : conj(nombre)}{true}{res $\igobs$ hippies(r)}{\Ode{1}}{Devuelve el conjunto de hippies presentes en el campus.}

\disDeclaraFuncion{Agentes}{\paramIn{r}{rastr}}{res : conj(agente)}{true}{res $\igobs$ agentes(r)}{\Ode{1}}{Devuelve el conjunto de agentes presentes en el campus.}

\disDeclaraFuncion{PosEstudiantesYHippie}{\paramIn{r}{rastr}, \paramIn{id}{nombre}}{res : posicion}{id $\in$ (estudiantes(r) $\cup$ hippies(cs))}{res $\igobs$ posEstudianteYHippie(id,r)}{\Ode{$\vert N_{m} \vert$}}{Devuelve la posici\'on del estudiante/hippie pasado como par\'ametro.}
\\
\disDeclaraFuncion{PosAgente}{\paramIn{r}{rastr}, \paramIn{a}{agente}}{res : posicion}{a $\in$ posAgente(a,r)}{res $\igobs$ posAgente(a,r)}{\Ode{1}}{Devuelve la posici\'on del agente pasado como par\'ametro. La complejidad se da en el caso promedio.}

\disDeclaraFuncion{CantSanciones}{\paramIn{r}{rastr}, \paramIn{a}{agente}}{res : nat}{a $\in$ cantSanciones(a,r)}{res $\igobs$ cantSanciones(a,r)}{\Ode{1}}{Devuelve la cantidad de sanciones recibidas por el agente pasado como par\'ametro. La complejidad se da en el caso promedio.}

\disDeclaraFuncion{CantHippiesAtrapados}{\paramIn{r}{rastr}, \paramIn{a}{agente}}{res : nat}{a $\in$ agentes(r)}{res $\igobs$ cantHippiesAtrapados(a,r)}{\Ode{1}}{Devuelve la cantidad de hippies atrapados por el agente pasado como par\'ametro. La complejidad se da en el caso promedio.}

\disDeclaraFuncion{ComenzarRastrillaje}{\paramIn{c}{campus}, \paramIn{d}{dicc(agente,posicion)}}{res : rastr}{($\forall$ a : agente)(def?(a,d) $\impluego$ (posValida?(obtener(a,d))) $\land$ $\¬$ocupada?(obtener(a,d),c)) $\land$ ($\forall$ a, $a_{2}$ : agente)((def?(a,d) $\land$ def?($a_{2}$,d) $\land$ a $\not=a_{2}$) $\impluego$ obtener(a,d)$\not=$ obtener($a_{2}$,d))}{res $\igobs$ comenzarRastrillaje(c,d)}{\Ode{1}}{Crea un Rastrillaje.}

\disDeclaraFuncion{IngresarEstudiante}{\paramInOut{r}{rastr}, \paramIn{e}{nombre}, \paramIn{p}{posicion}}{}{r = $r_{0}$ $\land$ e $\notin$ (estudiantes(r)$\cup$hippies(r)) $\land$ esIngreso?(p,campus(r)) $\land$ $\¬$estaOcupada?(p,r)}{r $\igobs$ ingresarEstudiante(e,p,$r_{0}$)}{\Ode{$\mid Nm \mid$}}{Modifica el rastrillaje, ingresando un estudiante al campus.}

\disDeclaraFuncion{IngresarHippie}{\paramInOut{r}{rastr}, \paramIn{h}{nombre}, \paramIn{p}{posicion}}{}{r = $r_{0}$ $\land$ h $\notin$ (estudiantes(r)$\cup$hippies(r)) $\land$ esIngreso?(p,campus(r)) $\land$ $\¬$estaOcupada?(p,r)}{r $\igobs$ ingresarHippie(h,p,$r_{0}$)}{\Ode{$\vert Nm \vert$}}{Modifica el rastrillaje, ingresando un hippie al campus.}

\disDeclaraFuncion{MoverEstudiante}{\paramInOut{r}{rastr}, \paramIn{e}{nombre}, \paramIn{dir}{direccion}}{}{r = $r_{0}$ $\land$ e $\in$ estudiantes(r) $\land$ (seRetira(e,dir,r) $\lor$ (posValida?(proxPosicion(posEstudianteYHippie(e,r),dir,campus(r)),campus(r)) $\land$ $\¬$ estaOcupada?(proxPosicion(posEstudianteYHippie(e,r),dir,campus(r)),r)))}{r $\igobs$ moverEstudiante(e,d,$r_{0}$)}{\Ode{$\vert Nm \vert$}}{Modifica el rastrillaje, al mover un estudiante del campus.}

\disDeclaraFuncion{MoverHippie}{\paramInOut{r}{rastr}, \paramIn{h}{nombre}}{}{r = $r_{0}$ $\land$ h $\in$ hippies(r) $\land$ $\¬$todasOcupadas?(vecinos(posEstudianteYHippie(h,r),campus(r)),r) }{r $\igobs$ moverHippie(r,$r_{0}$)}{\Ode{$\vert Nm \vert$} $+$ \Ode{Ne}}{Modifica el rastrillaje, al mover un hippie del campus.}

\disDeclaraFuncion{MoverAgente}{\paramInOut{r}{rastr}, \paramIn{a}{agente}}{}{r = $r_{0}$ $\land$ a $\in$ agentes(r) $\yluego$ cantSanciones(a,r) $\leq$ 3 $\land$ $\¬$todasOcupadas?(vecinos(posAgente(a,r),campus(r)),r)}{r $\igobs$ moverAgente(a,$r_{0}$)}{\Ode{$\vert Nm \vert$} $+$ \Ode{log Na} $+$ \Ode{Ne}}{Modifica el rastrillaje, al mover un agente del campus.}

\disDeclaraFuncion{MasVigilante}{\paramIn{r}{rastr}}{res : agente}{true}{res $\igobs$ masVigilante(r)}{\Ode{1}}{Devuelve el agente con mas capturas.}

\disDeclaraFuncion{ConKSanciones}{\paramIn{r}{rastr}, \paramIn{k}{nat}}{res : conj(agente)}{true}{res $\igobs$ conKSanciones(k,r)}{\Ode{Na} \diagup \Ode{log Na}}{Devuelve el agente con mas capturas. La primera vez que se llama ser\'a \Ode{Na} luego mientras no haya sanciones, \Ode{log Na}.}

\disDeclaraFuncion{ConMismasSanciones}{\paramIn{r}{rastr}, \paramIn{a}{agente}}{res : conj(agente)}{a $\in$ agentes(r)}{res $\igobs$ conMismasSanciones(a,r)}{\Ode{1}}{Devuelve el conjunto de agentes con la misma cantidad de sanciones que a.}





\disPautasDeImplementacion

\disEstructuraDeRepresentacion

\disSeRepresentaCon{campus}{estr}
\disDondeEs{estr}{\disTuplaEstr{campus/campo, diccPromedio(agente ; datosAg)/agentes, arreglo(tupla(placa;posicion))/posAgentesLog, conjLineal(datosHoE)/hippies, conjLineal(datosHoE)/estudiantes, diccString(nombre;posicion)/posCiviles, diccLineal(nombre;posicion)/posRapida, vector(vector(datosPos))/quienOcupa, itConj(agente)/masVigilante, lista(datosK))/agregoEn1, vector(datosK)/buscoEnLog, bool/hayNuevas }}

\disDondeEs{datosAg}{\disTuplaEstr{nat/QSanciones, nat/premios, posicion/posActual, itConj(agente)/grupoSanciones, itLista(datosK)/verK}}

\disDondeEs{datosHoE}{\disTuplaEstr{nombre/ID, itDicc(nombre;posicion)/posActual}}

\disDondeEs{datosPos}{\disTuplaEstr{bool/ocupada?, clases/queHay, itDicc(agente)/hayCana, itConj(nombre)/hayHoE}}

\disDondeEs{clases}{enum\{``agente'',``estudiante'',``hippie'',``obstaculo'',``nada''\}}

\disDondeEs{datosK}{\disTuplaEstr{nat/K, conjLineal(agente)/grupoK}}

\disJustificacionDeLaEstructuraElegida
{Para entender mejor la estructura damos una explicaci\'on:\\
$campo$ es el campus que utiliza el rastrillaje, este indica las dimensiones de la cuadricula y la ubicacion de los obstaculos;
$agentes$ es un diccionario que dado un agente(nro de placa) devuelve,en tiempo promedio si las condiciones son las adecuadas,una tupla con sus datos: cuantas veces fue sancionado, cuantos hippies capturo, en que posicion se encuentra actualmente
, un iterador al conjunto de agentes con sus mismas sanciones, y un iterador a una lista de $datosK$: estas son tuplas compuestas por un numero natural K y un conjunto de agentes que comparten la cantidad de sanciones(k).
$posAgentesLog$ es un arreglo de tuplas(placa,posicion) ordenadas de menor a mayor placa, haciendo que la busqueda de un elemento en este arreglo sea de complejidad logaritmica.\\
$hippies$ y $estudiantes$ son conjuntos de $datosHoE$, estos son tuplas (Nombre, posicion). En dichos conjuntos estan incluidos todos los hippies y estudiantes respectivamente.\\
$posCiviles$ es un diccionario en el que las claves son los nombres de todos los hippies y estudiantes presentes en el rastrillaje y los significados son las posciones actuales de cada clave\\
$posRapida$ es un diccionario lineal utilizado para calcular en tiempo lineal a donde debe moverse un agente o hippie (hacia el hippie o estudiante mas cercano respectivamente)\\
$quienOcupa$ es una matriz con las dimensiones del campus, en la que se recopilan las posiciones de todos los civiles, agentes y obstaculos del rastrillaje, indicando así en cada posicion de la matriz quien o que la esta ocupando en caso de no estar libre la posiccion\\
$masVigilante$ es un interador al conjunto de agentes, que indica cual de todos estos es aquel que participo en la mayor cantidad de capturas, y en caso de haber mas de uno este iterador apunta al agente de menor placa entre estos\\
$agregoEn1$ es una lista de datosK que es utilzada como rueda de auxilio a la hora de sancionar a un agente para seguir teniendo en orden de cantidad de sanciones a los agentes, para poder asi cumplir con la complejidad pedida en ``conKsanciones"\\
$hayNuevas$ es un booleano que indica si entre dos usos de la funcion ``conKsanciones" hubo sanciones a algun agente, para asi poder saber si hay que buscar al conjunto de agentes en $buscoEnLog$, siendo así en tiempo logaritmico o si primero debo copiar los datos de $agregoEn1$ en $buscoEnLog$ y luego hacer la busqueda.
}  
\disInvarianteDeRepresentacion
\hspace*{\disSubSubSecMargen}\textbf{\textsf{Informal}}

\hspace*{\disSubSubSecMargen}
\begin{enumerate}
\setlength{\itemindent}{3em}
  \item Todos los agentes tienen distinta posicion.
  \item La cantidad de sanciones se ve reflejada dos veces en la tupla DatosAg y debe ser la misma.
  \item Si dos agentes tienen la misma cantidad de sanciones, pertenecen al mismo grupo. En caso contrario, sus grupos son disjuntos.
  \item Todas las posiciones estan dentro del rango permitido en el campus.
  \item El conjunto que contiene a todas las placas de posAgentesLog es igual al conjunto de claves de agentes. 
  \item Todas las posiciones de los agentes son los significados del diccionario $"agentes"$ y tambien se ven en $"posAgentesLog"$ y son las mismas.
    \item posAgentesLog y buscoEnLog estan en orden

  \item La union de los gruposK pertenecientes a $"agregoEn1"$ es igual al conjunto de claves de agentes.
  \item Ningun hippie, estudiante o agente comparte posicion con otra persona u obstaculo.
    \item Los conjuntos hippies y estudiantes son disjuntos

  \item La union de los conjuntos de nombres de estudiantes y nombres de hippies es igual al conjunto de claves del diccionario posCiviles
  \item En todas las posiciones de quienOcupa que esten en rango, la primer coordenada indica si esa posicion esta ocupada o no. La segunda quien esta ocupandola, si hubiera alguien, y las otras dos tienen iteradores al conjunto correspondiente(el que contiene a quien esta ocupando esa posicion)
  \item Todos los $"K"$ pertenecientes a e.agregoEn1 y a e.buscoEnLog son iguales a la cantidad de sanciones de algun agente, y ese agente pertenece al grupo relacionado con K.
  \item El masVigilante es el agente con mas premios, en caso de haber mas de uno, es el de menor placa.
  \item e.hayNuevas es falsa Sii la longitud de e.buscoEnLog y de e.agregoEn1 y tienen los mismos elementos en el mismo orden
  
\end{enumerate}
\newpage
\hspace*{\disSubSubSecMargen}\textbf{\textsf{Formal}}
\onehalfspace
\disRep{estr}{e}{$true$ $\Longleftrightarrow$ 
\\\hspace*{3.75em}(1)(2)(3)(4) ($\forall$ a,a2: Agente)(a $\neq$ a2 $\wedge$ definido?(a,e.agentes) $\wedge$ definido?(a2,e.agentes) \\\hspace*{3em} $\yluego$ PosValida(e.campo,obtener(a,e.agentes).PosActual) $\wedge$ PosValida(e.campo,obtener(a2,e.agentes).PosActual))) \\\hspace*{3em} $\impluego$  obtener(a,e.agentes).PosActual $\neq$ obtener(a2,e.agentes).PosActual \\\hspace*{3em} $\wedge $ (obtener(a,e.agentes).Qsanciones=siguiente(obtener(a,e.agentes).verK).K \\\hspace*{3em} $\wedge$ obtener(a,e.agentes).grupoSanciones=siguiente(obtener(a,e.agentes).verK).grupoK \\\hspace*{3em} $\wedge$ (a2 $\in$ obtener(a,e.agentes).grupoSanciones) $\Longleftrightarrow$ (obtener(a,e.agentes).Qsanciones = obtener(a2,e.agentes).Qsanciones) \\\hspace*{3em} $\wedge$ (5) TodasLasPlacas(e,e.posAgentesLog)= claves(e.agentes) \\\hspace*{3em} $\wedge$ (6) ($\forall$ a3:agente, t: tupla(agente,posicion))(t $\in$ e.posAgentesLog $\wedge$ a3= $\Pi_{1}$(t)  $\yluego$ definido?(a3,e.agentes) $\impluego$ obtener(a3,e.agentes)= $\Pi_{2}$(t))
 \\\hspace*{3em} $\wedge$  (7) enOrden(e.posAgentesLog) $\wedge$ enOrden(e.buscoEnLog)  \\\hspace*{3em} $\wedge$ (8) UnionConjuntos(e,e.agregoEn1)=claves(e.agentes) \\\hspace*{3em} $\wedge$ (9) ($\forall$ h,h1:tupla(nombre,itDicc(nombre;posicion)))(h $\in$ e.hippies $\wedge$ h1 $\in$ e.hippies $\wedge$ $\Pi_{1}$(h) $\neq$ $\Pi_{1}$(h1)) $\impluego$ ($\Pi_{2}$(h) $\neq$ $\Pi_{2}$(h1)) $\wedge$ ($\forall$ es,es1:tupla(nombre,itDicc(nombre;posicion)))(es $\in$ e.estudiantes $\wedge$ es1 $\in$ e.estudiantes $\wedge$ $\Pi_{1}$(h) $\neq$ $\Pi_{1}$(h1)) $\impluego$ ($\Pi_{2}$(h) $\neq$ $\Pi_{2}$(h1)) \\\hspace*{3em}
 $\wedge$ e.posCiviles=e.posRapida $\wedge$ ($\forall$ hi:nombre,e:nombre)((hi $\neq$ e $\wedge$ definido?(hi,e.posCiviles) $\wedge$ definido?(e,e.posCiviles)) $\impluego$ obtener(e,e.posCiviles) $\neq$ obtener(hi,e.posCiviles) \\\hspace*{3em}$\wedge$ ($\forall$ a:agente, civ:nombre)(definido?(a,e.agentes) $\wedge$ definido?(civ,e.posCiviles)) \\\hspace*{3em} $\impluego$ (obtener(a,e.agentes) $\neq$ obtener(civ,e.posCiviles)) $\wedge$ (10) (e.hippies $\cap$ e.estudiantes)= $\emptyset$ \\\hspace*{3em} $\wedge$ (11) JuntaNombres(e.estudiantes)$\cup$JuntaNombres(e.hippies)=claves(e.posCiviles)) \\\hspace*{3em} $\wedge$ (12) ($\forall$ i:nat, j:nat)(i$\geq$0 $\wedge$ i$<$e.campo.filas $\wedge$ j$\geq$0 $\wedge$ j$<$e.campo.columnas) $\impluego$ \IF $\Pi_{1}$(e.quienOcupa[i][j])=false \\\hspace*{3em} THEN $\Pi_{2}$(e.quienOcupa[i][j]) = $"nada"$ \\\hspace*{3em} ELSE \IF $\Pi_{2}$(e.quienOcupa[i][j]) = "hippie" $\vee$ $\Pi_{2}$(e.quienOcupa[i][j]) = $"estudiante"$ THEN $\Pi_{3}$(e.quienOcupa[i][j])=crearIt(e.agentes) $\wedge$ $\Pi_{4}$(e.quienOcupa[i][j])$\neq$ crearIt(e.diccString) ELSE   $\Pi_{4}$(e.quienOcupa[i][j])=crearIt(e.diccString) $\wedge$ $\Pi_{3}$(e.quienOcupa[i][j])$\neq$crearIt(e.agentes) FI FI \\\hspace*{3em} $\wedge$ ($\forall$ k:nat)(($\exists$ i:nat)(i$\geq$0 $\wedge$ i$<$longitud(e.agregoEn1) $\impluego$ e.agregoEn1[i].K=k) $\Longleftrightarrow$ ($\exists$ ag:agente)(definido?(ag,e.agentes) $\impluego$ obtener(ag,e.agentes).Qsanciones=k $\wedge$ ag $\in$ e.agregoEn1[i].grupoK)) \\\hspace*{3em} $\wedge$ (13) ($\forall$ k:nat)(($\exists$ i:nat)(i$\geq$0 $\wedge$ i$<$longitud(e.buscoEnLog) $\impluego$ e.buscoEnLog[i].K=k) $\Longleftrightarrow$ \\\hspace*{3em} ($\exists$ ag:agente)(definido?(ag,e.agentes) $\impluego$ obtener(ag,e.agentes).Qsanciones=k $\wedge$ ag $\in$ e.buscoEnLog[i].grupoK)) \\\hspace*{3em} $\wedge$ (14) ($\forall$ age:agente)(definido?(age,e.agentes) $\wedge$ definido?(siguiente(e.masVigilante),e.agentes) \\\hspace*{3em} $\impluego$ (obtener(age,e.agentes).premios$\leq$ obtener(siguiente(e.masVigilante),e.agentes).premios \\\hspace*{3em} $\wedge$ obtener(age,e.agentes).premios=obtener(siguiente(e.masVigilante),e.agentes).premios \\\hspace*{3em} $\Rightarrow$ siguiente(e.masVigilante) $<$ age ) \\\hspace*{3em} $\wedge$ (15) e.hayNuevas=false $\Longleftrightarrow$ (longitud(e.agregoEn1)=longitud(e.buscoEnLog) $\yluego$ ($\forall$ i$\geq$0 $\wedge$ i$<$ longitud(e.agregoEn1) (e.agregoEn1[i]=e.buscoEnlog[i])) }
 \singlespace
\disFuncionDeAbsFuncionesAux 	
\tadOperacion{\tadNombreFuncion{\hspace*{3.7em}TodasLasPlacas}}{secu(tupla(agente,posicion))}{conj(agente)}{}
\tadAxioma{\hspace*{2.3em}TodasLasPlacas(s)}{{\textbf{if }vacia $?$(s)\hspace{1cm}\textbf{then}\hspace{1cm} \emptyset \hspace{1cm}\textbf{else}\hspace{1cm} Ag(\Pi_{1}(prim(s)),TodasLasPlacas(fin(s)))}}
\singlespace
\tadOperacion{\tadNombreFuncion{\hspace*{3.7em}enOrden}}{secu(tupla(nat,$\alpha$)}{bool}{}
\tadAxioma{\hspace*{2.3em}enOrden(s)}{{\textbf{if }vacia 
 $?$(s) $\vee$ longitud(s)=1 \hspace{1cm}\textbf{then}\hspace{1cm} true \hspace{1cm}\textbf{else}\hspace{1cm} \\ ($\Pi_{1}$(prim(s))$\leq$ $\Pi_{1}$(prim(fin(s))) $\wedge$ enOrden(fin(s))}}
 \tadOperacion{\tadNombreFuncion{\hspace*{3.7em}unionConjuntos}}{secu(tupla(nat,conj($\alpha$))}{conj($\alpha$)}{}
\tadAxioma{\hspace*{2.3em}unionConjuntos(s)}{\textbf{if }vacia $?$(s)\hspace{1cm}\textbf{then}\hspace{1cm} \emptyset \hspace{1cm}\textbf{else}\hspace{1cm} \Pi_{2}(prim(s)) $\cup$ unionConjuntos(fin(s))}





\disFuncionDeAbstraccion
\vspace*{-1em}
%\hspace*{\disSubSubSecMargen}{Texto}
\disAbs{estr}{e}{CampusSeguro}{cs}{\Big(campus(cs) = e.campo $\land$ estudiantes(cs) = juntaNombres(e.estudiantes) $\land$ hippies(cs)=juntaNombres(e.hippies)  \\\hspace*{3em} $\land$ agentes(cs)=claves(e.agentes)  \\\hspace*{3em} $\land$ ($\forall$ n:nombre) (n$\in$ hippies(cs) $\cup$ estudiantes(cs) $\impluego$ posEstudianteYHippie(n,cs) =obtener(n,e.posCiviles))  \\\hspace*{3em}$\land$ ($\forall$ a:agente) (a$\in$ agentes(cs) $\impluego$ posAgente(a,cs) = \Pi_{3}(obtener(n,e.agentes))  \\\hspace*{3em}$\land$ cantSanciones(a,cs)=\Pi_{1}(obtener(n,e.agentes)) $\land$ cantHippiesAtrapados(a,cs) =\Pi_{2}(obtener(n,e.agentes)))\Big) }

\singlespace
\disFuncionDeAbsFuncionesAux
\tadOperacion{\tadNombreFuncion{\hspace*{3.7em}juntaNombres}}{conj(datosHoE)}{conj(nombre)}{}
\tadAxioma{\hspace*{2.3em}juntaNombres(c)}{\textbf{if }\emptyset $?$(c)\hspace{1cm}\textbf{then}\hspace{1cm} \emptyset \hspace{1cm}\textbf{else}\hspace{1cm} ag(\Pi_{1}(dameUno(c)),juntaNombres(sinUno(c))) }\mbox{}


%\disFuncionDeAbsFuncionesAux


\newpage

\disAlgoritmos
%\hspace*{\disSubSubSecMargen}{Texto}
% HACK: SGA 28/05/2011. Para quitar el titulo Algorithm del caption \floatname{algorithm}{}
\floatname{algorithm}{}
% WARNING: SGA 27/05/2011. La opción [H] indica a LaTex que el algoritmo lo queremos AQUI!
% Ver 4.4.1 Placement of Algorithms de algorithms.pdf.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Campus}}{\paramIn{e}{estr}}{$\disFlecha$ res : campus} \Comment{$\Ode{1}$}
  \State res $\gets$ e.campo
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Estudiantes}}{\paramIn{e}{estr}}{$\disFlecha$ res : itConj(nombre)} \Comment{$\Ode{1}$}
  \State res $\gets$ crearIt (e.estudiantes)
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Hippies}}{\paramIn{e}{estr}}{$\disFlecha$ res : itConj(nombre)} \Comment{$\Ode{1}$}
  \State res $\gets$ crearIt (e.hippies)
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Agentes}}{\paramIn{e}{estr}}{$\disFlecha$ res : itConj(agente)} \Comment{$\Ode{1}$}
  \State res $\gets$ claves(e.agentes) 
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$posEstudiantesYHippie}}{\paramIn{e}{estr}, \paramIn{n}{nombre}}{$\disFlecha$ res : posicion} \Comment{$\Ode{\vert N_{m} \vert}$}
    \State res $\gets$ obtener(n,e.posCiviles)
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$posAgente}}{\paramIn{e}{estr} \paramIn{a}{agente}}{$\disFlecha$ res : posicion} \Comment{$\Ode{1}(promedio)$}
    \State res $\gets$ obtener(a,e.agentes).posActual
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$cantSanciones}}{\paramIn{e}{estr}, \paramIn{a}{agente}}{$\disFlecha$ res : nat} \Comment{$\Ode{1}(promedio)$}
    \State res $\gets$ obtener(a,e.agentes).Qsanciones
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$cantHippiesAtrapados}}{\paramIn{e}{estr}, \paramIn{a}{agente}}{$\disFlecha$ res : nat} \Comment{$\Ode{1}(promedio)$}
    \State res $\gets$ obtener(a,e.agentes).premios
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$masVigilante}}{\paramIn{e}{estr}}{$\disFlecha$ res : agente} \Comment{$\Ode{1}$}
    \State res $\gets$ siguiente(e.masVigilante)
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$conMismasSanciones}}{\paramIn{e}{estr} \paramIn{a}{agente}}{$\disFlecha$ res : conj(agente)} \Comment{$\Ode{1}$}
    \State res $\gets$ siguiente(obtener(e.agentes,a).grupoSanciones)
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$conKSanciones}}{\paramIn{e}{estr} \paramIn{k}{nat}}{$\disFlecha$ res : conj(agente)} \Comment{$\Ode{Na}$ la primera vez, luego mientras no haya sanciones $\Ode{log Na}$}
	\If {$\neg$e.hayNuevas} \Comment{$\Ode{1}$}
		 \State var nat i $\gets$ BusquedaBin(e.buscoEnLog, k) \Comment{$\Ode{log Na}$}
		 \State res $\gets$ e.buscoEnLog$_{[i]}$.grupoK \Comment{$\Ode{1}$}
	\Else
		 \State var itLista(datosK) itK $\gets$ crearIt(e.agregoEn1) \Comment{$\Ode{1}$}
		 \While {haySiguiente(it)} \Comment{$\Ode{1}$}
		 	\State buscoEnLog $_{[i]}$ $\gets$ siguiente(itK) \Comment{$\Ode{1}$}
		 	\State avanzar(itK)
		 \EndWhile
		 \State var nat i $\gets$ BusquedaBin (e.buscoEnLog, k) \Comment{$\Ode{log Na}$}
		 \State res $\gets$ e.buscoEnLog$_{[i]}$.grupoK \Comment{$\Ode{1}$}
		 \State e.hayNuevas $\gets$ false \Comment{$\Ode{1}$}
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$ComenzarRastrillaje}}{\paramIn{c}{campus} \paramIn{d}{dicc(placa,posicion)}}{$\disFlecha$ res : estr} \Comment{$\Ode{1}$}
    \State var diccPromedio(placa,datosAg) dprom $\gets$ vacio($\#$claves(d))	\Comment{$\Ode{\#claves(d)}$}
    \State var lista(datosK) Klista $\gets$ vacia()								\Comment{$\Ode{1}$}	
    \State var vector(vector(datosPos)) map $\gets$ vacia()						\Comment{$\Ode{1}$}
    \State \textbf{for} i=0 \textbf{to} filas?(c) \textbf{do}					\Comment{$\Ode{columnas?(c)^{2}*filas?(c)^{2}}$}
    	\State var vector(datosPos) filita $\gets$ vacia()						\Comment{$\Ode{1}$}
    	\State \textbf{for} j=0 \textbf{to} columnas?(c) \textbf{do} 			\Comment{$\Ode{columnas?(c)}$}
		\If {ocupada?(c,(j,i))}													\Comment{$\Ode{1}$}
			\State AgAtras(filita,$<$true,$"obstaculo"$,crearIt(),crearIt()$>$)	\Comment{$\Ode{columnas?(c)}$}
		\Else
			\State AgAtras(filita,$<$false,$"nada"$,crearIt(),crearIt()$>$)		\Comment{$\Ode{columnas?(c)}$}
		\EndIf
		\State \textbf{EndFor}										
		\State AgAtras(map,filita)												\Comment{$\Ode{filas?(c)}$}
	\State \textbf{EndFor}
	\State var Arreglo($<$placa,posicion$>$) arr $\gets$ crearArreglo[$\#$claves(d)]	\Comment{$\Ode{\#claves(d)}$}
	\State var itDicc(placa,posicion) iter $\gets$ crearIt(d)							\Comment{$\Ode{1}$}
    \State var itLista(datosK) itk $\gets$ AgregarAtras(Klista,$<$0,vacio$>$)			\Comment{$\Ode{1}$}
	\While {haySiguiente(iter)}															\Comment{$\Ode{\#claves(d)}$}	
		\State AgregarOrdenado(arr,$<$SiguienteClave(iter),SiguienteSignificado(iter)$>$)	\Comment{$\Ode{(\#claves(d))^{2}}$}
		\State var datosAg datosN $\gets$ $<$0,0,SiguienteSignificado(iter),Agregar(Siguiente(itK).grupoK,SiguienteClave(iter)),itK$>$
		\State
		\State map[SiguienteSignificado(iter.X)][SiguienteSignificado(iter.Y)] $\gets$ $<$true,$"agente"$,definirRapido(dprom,
		\\\hspace*{3em}SiguienteClave(iter),datosN),crearIt()$>$ 	\Comment{$\Ode{1}$}
		\State
		\State avanzar(iter)	\Comment{$\Ode{1}$}
	\EndWhile
	\State var conj(datosHoE) hip $\gets$ vacio()	\Comment{$\Ode{1}$}
	\State var conj(datosHoE) est $\gets$ vacio()	\Comment{$\Ode{1}$}
	\State var diccString(nombre,posicion) diccS $\gets$ vacio()	\Comment{$\Ode{1}$}
	\State var diccLineal(nombre,posicion) diccL $\gets$ vacio()	\Comment{$\Ode{1}$}
	\State var itConj(placa) masV $\gets$ crearIt(dprom)	\Comment{$\Ode{1}$}
	\State var bool hayNuevasS $\gets$ true	\Comment{$\Ode{1}$}
	\State var vector(datosK) paraLog $\gets$ vacia()	\Comment{$\Ode{1}$}
	\State res $\gets$ $<$c,dprom,arr,hip,est,diccS,diccL,map,masV,kLista,paraLog,hayNuevasS$>$	\Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}




\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$ingresarEstudiante}}{\paramInOut {e}{estr}, \paramIn {n}{nombre}, \paramIn {p}{posicion}} \Comment{$\Ode{\mid Nm \mid}$}
\If {esHippizable(e,p)} \Comment{$\Ode{1}$}
		\If {esCapturable(e,p)} \Comment{$\Ode{1}$}
			\State var conj(posicion) v $\gets$ vecinos(e.campus, p) \Comment{$\Ode{1}$}
			\State var itConj(posicion) it $\gets$ crearIt(v) \Comment{$\Ode{1}$}
			\While {haySiguiente(it)}
				\If {e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.queHay == $"$agente"} \Comment{$\Ode{1}$}
					\State recompensar(e, siguiente(it)) \Comment{$\Ode{1}$}
				\EndIf
				\State avanzar(it)	\Comment{$\Ode{1}$}
			\EndWhile
		\Else
			\State definir(e.posCiviles, n, p)  \Comment{$\Ode{\mid Nm \mid}$}
			\State var itDicc(nombre, posicion) iterPos $\gets$ definirRapido(e.posRapida,n,p) \Comment{$\Ode{1}$}
			\State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$ true,"hippie",crearIt(), agregarRapido(e.hippies,$<$n,iterPos$>$)$>$ \Comment{$\Ode{1}$}
			\State var conj(posicion) Ps $\gets$ vecinos(e.campus, p) \Comment{$\Ode{1}$}
			\State var itConj(posicion) it $\gets$ crearIt(Ps) \Comment{$\Ode{1}$}
			\While {haySiguiente(it)} 
				\If {esEstudiante(e,siguiente(it)) $\wedge$ esHippizable(e,siguiente(it))} \Comment{$\Ode{1}$}
					\State Hippizar(e, siguiente(it)) \Comment{$\Ode{1}$}
					\If {esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
						\State capturarHippie(e,siguiente(it)) \Comment{$\Ode{\mid Nm \mid}$}
					\EndIf
				\Else
					\If {esEstudiante(e,siguiente(it)) $\wedge$ esCapturable(e, siguiente(it))} \Comment{$\Ode{1}$}
						\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
						\While {haySiguiente(itAg)}  \Comment{$\Ode{1}$}
							\If {esAgente(e, siguiente(itAg))} \Comment{$\Ode{1}$}
								\State sancionar(e,siguiente(itAg)) \Comment{$\Ode{1}$}
							\EndIf
							\State avanzar(itAg)	\Comment{$\Ode{1}$}
						\EndWhile
					\Else
						\If {esHippie(e, siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))}  \Comment{$\Ode{1}$}
							\State capturarHippie(e,siguiente(it)) \Comment{$\Ode{\mid Nm \mid}$}
						\EndIf
					\EndIf
				  \EndIf
					\State avanzar(it)	\Comment{$\Ode{1}$}
				\EndWhile
			  \EndIf
			\Else
				\State definir(e.posCiviles, n, p)  \Comment{$\Ode{\mid Nm \mid}$}
				\State var itDicc(nombre, posicion) iterPos $\gets$ definirRapido(e.posRapida, n, p)  \Comment{$\Ode{1}$}
				\State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$ true,$"$estudiante",crearIt(), agregarRapido(e.estudiantes,$<$n,iterPos$>$)$>$
				\State var conj(posicion) Ps $\gets$ vecinos(e.campus, p) \Comment{$\Ode{1}$}
				\State var itConj(posicion) it $\gets$ crearIt(ps) \Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]			
				\While {haySiguiente(it)}
					\If {esHippie(e,siguiente(it)) $\wedge$ esEstudiantizable(e,siguiente(it))} \Comment{$\Ode{1}$}
						\State Estudiantizar(e,siguiente(it)) \Comment{$\Ode{1}$}
					\Else
						\If {esEstudiante(e,siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
							\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
							\While {haySiguiente(itAg)}
								\If {esAgente(e,siguiente(itAg))} \Comment{$\Ode{1}$}
									\State Sancionar(e,siguiente(itAg)) \Comment{$\Ode{1}$}
								\EndIf
								\State avanzar(itAg)	\Comment{$\Ode{1}$}
							\EndWhile
						\Else
							\If {esHippie(e,siguiente(it) $\wedge$ esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
								\State	capturarHippie(e,siguiente(it))  \Comment{$\Ode{\mid Nm \mid}$}
							\EndIf
						\EndIf
					\EndIf
				\EndWhile
			\EndIf
\textbf{endFunction}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$ingresarHippie}}{\paramInOut{e}{estr} \paramIn{p}{posicion} \paramIn{h:nombre}}{} \Comment{$\Ode{\vert Nm \vert}$}
	\State definir(e.posCiviles, h,p) \Comment{$\Ode{\vert Nm \vert}$}
	\State var itDicc(nombre,posicion) iterPos $\gets$ definirRapido(e.posRapida,h,p) \Comment{$\Ode{1}$}
	\State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$ true, "hippie", crearIt(), agregarRapido(e.hippies,$<$h,iterPos$>$)$>$ \Comment{$\Ode{1}$}
	\State var conj(posicion) Ps $\gets$ vecinos(e.campus,p) \Comment{$\Ode{1}$}
	\State var itConj(posicion) $\gets$ crearIt(ps) \Comment{$\Ode{1}$}
	\If {esCapturable(e,p)} \Comment{$\Ode{1}$}
		\State capturarHippie(e,p) \Comment{$\Ode{\vert Nm \vert}$}
	\Else
		\While {haySiguiente(it)} \Comment{$\Ode{1}$}
			\If {ocupada(e.campus, siguiente(it)) $\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?} \Comment{$\Ode{1}$}
				\State avanzar(it) \Comment{$\Ode{1}$}
			\Else
				\If {esEstudiante(e,siguiente(it)) $\wedge$ esHippizable(e,siguiente(it))} \Comment{$\Ode{1}$}
					\State Hippizar(e, siguiente(it)) \Comment{$\Ode{1}$}
					\If {esCapturable(e,siguiente(it)}	 \Comment{$\Ode{1}$}
						\State capturarHippie(e,siguiente(it))  \Comment{$\Ode{\vert Nm \vert}$}
					\EndIf 
				\Else 
					\If {esEstudiante(e,siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
						\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
						\While {haySiguiente(itAg)} \Comment{$\Ode{1}$}
							\If {esAgente(siguiente(itAg)} \Comment{$\Ode{1}$}
								\State sancionar(e,siguiente(itAg)) \Comment{$\Ode{1}$}
							\EndIf
							\State avanzar(itAg)	\Comment{$\Ode{1}$}
						\EndWhile
   					 \EndIf
				\EndIf
			\EndIf
			\State avanzar(it)	\Comment{$\Ode{1}$}
		\EndWhile
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \algsetup{\footnotesize}
  \scriptsize
\begin{algorithmic}[1]
\Function {\textsc{$i$moverEstudiante}}{\paramInOut{e}{estr}, \paramIn{d}{direccion}, \paramIn{s}{estudiante}}{} \Comment{$\Ode{\vert Nm \vert}$}
	\State var posicion actual $\gets$ obtener(e.posCiviles,s)  \Comment{$\Ode{1}$}
	\State var posicion prx $\gets$ proxPosicion(e.campus, d, actual)  \Comment{$\Ode{1}$}
	\If {seFue?(e.campus,actual, prx)}
		\State borrar(e.posCiviles, s) \Comment{$\Ode{\vert Nm \vert}$}
		\State var itConj(datosHoE) dat $\gets$ copia(e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$.hayHoE) \Comment{$\Ode{1}$}
		\State eliminarSiguiente(dat, posActual) \Comment{$\Ode{1}$}
		\State eliminarSiguiente(dat) \Comment{$\Ode{1}$}
		\State e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$ $\gets$ $<$ false, "nada", crearIt(), crearIt() $>$ \Comment{$\Ode{1}$}
	\Else
		\State var itConj(datosHoE) iterAHOI $\gets$ copia(e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$.hayHoE) \Comment{$\Ode{1}$}
		\State eliminarSiguiente(siguiente(iterAHOI).posActual) \Comment{$\Ode{1}$}
		\State siguiente(iterAHOI).posActual $\gets$ definirRapido(e.posRapida,s,prx) \Comment{$\Ode{1}$}
		\State e.quienOcupa$_{[prx.X]}$ $_{[prx.Y]}$ $\gets$ $<$true, $"$estudiante$"$, crearIt(), iterAHOI$>$ \Comment{$\Ode{1}$}
		\State e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$ $\gets$ $<$false, "nada", crearIt(), crearIt()$>$ \Comment{$\Ode{1}$}
		\State definir(e.posCiviles, s, prx) \COmment{$\Ode{\vert Nm \vert}$}
		\State var conj(posicion) vc $\gets$ vecinos(e.campus, prx) \Comment{$\Ode{1}$}
		\State var itConj(posicion) it $\gets$ crearIt(vc) \Comment{$\Ode{1}$}
		
		\If {esHippizable(e,prx)} \Comment{$\Ode{1}$}
			\State hippizar(e, prx) \Comment{$\Ode{1}$}
			\While {haySiguiente(it} \Comment{$\Ode{1}$}
				\If {ocupada(e.campus, siguiente(it)) $\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?}
					\State avanzar(it)\Comment{$\Ode{1}$}
				\Else \If {esEstudiante(e,siguiente(it)) $\wedge$ esHippizable(e,siguiente(it))} \Comment{$\Ode{1}$}
						 \State Hippizar(e, siguiente(it))  \Comment{$\Ode{1}$}
						 \If {esCapturable(e, siguiente(it))}  \Comment{$\Ode{1}$}
						 	\State capturarHippie(e,siguiente(it))  \Comment{$\Ode{\vert Nm \vert}$}
						 \EndIf
					  \Else \If {esEstudiante(e,siguiente(it) $\wedge$ esCapturable(e,siguiente(it)} \Comment{$\Ode{1}$}
					  			\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
					  			\While {haySiguiente(itAg)} \Comment{$\Ode{1}$}
					  				\If {esAgente(e,siguiente(itAg)} \Comment{$\Ode{1}$}
					  					\State sancionar(e,siguiente(itAg)) \Comment{$\Ode{1}$}
					  				\EndIf
					  			\State avanzar(itAg)\Comment{$\Ode{1}$}
					  			\EndWhile
					  		\Else
					  			\If {esHippie(e,siguiente(it)) $\wedge$ esCapturable(s,siguiente(it))} \Comment{$\Ode{1}$}
					  				\State capturarHippie(e,siguiente(it))  \Comment{$\Ode{\vert Nm \vert}$}
					  			\EndIf	
					  		\EndIf
					  	\EndIf
				\EndIf
			\EndWhile
		\Else
			\While {haySiguiente(it)}
			\If {ocupada(e.campus, siguiente(it))$\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?} \Comment{$\Ode{1}$}
					\State avanzar(it)
				\Else
					\If {esHippie(e, siguiente(it)) $\wedge$ esEstudiantizable(e,siguiente(it))} \Comment{$\Ode{1}$}
						\State Estudiantizar(e, siguiente(it)) \Comment{$\Ode{1}$}
					\Else
						\If {esEstudiante(e,siguiente(it)) $\wedge$ esCapturable(e, siguiente(it))} \Comment{$\Ode{1}$}
							\State var itConj(posicion) itAg2 $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
							\While {haySiguiente(itAg2)} \Comment{$\Ode{1}$}
								\If {esAgente(e,siguiente(itAg2))} \Comment{$\Ode{1}$}
									\State sancionar(e,siguiente(itAg2)) \Comment{$\Ode{1}$}
								\EndIf
								\State avanzar(itAg2)
							\EndWhile
						\Else
							\If {esHippie(e, siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
								\State capturarHippie(e, siguiente(it))  \Comment{$\Ode{\vert Nm \vert}$}
							\EndIf
						\EndIf
					\EndIf
				\EndIf
				\State avanzar(it)
			\EndWhile
		\EndIf
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$moverAgente}}{\paramInOut{e}{estr} \paramIn{a}{agente}}{} \Comment{$\Ode{\vert Nm \vert}+\Ode{log Na}+\Ode{Ne}$}
    \State var nat j $\gets$ BusquedaBin(e.AgentesLog,a) \Comment{$\Ode{log Na}$}
    \State var posicion actual $\gets$ e.AgentesLog$_{[j]}$ \Comment{$\Ode{1}$}
    \State var direccion d $\gets$ proxPosicionA(e,a) \Comment{$\Ode{Ne}$}
    \State var posicion prx $\gets$ proxPosicion(e.campus, d, actual) \Comment{$\Ode{1}$}
    \State var datosAg datAux $\gets$ obtener(e.agentes, a) \Comment{$\Ode{1}$}
    \State datAux.posActual $\gets$ prx \Comment{$\Ode{1}$}
    \State var itDicc(placa,datosAg) itA $\gets$ copia(e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$.hayCana) \Comment{$\Ode{1}$}
    \State e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$ $\gets$ $<$false, "nadie", crearIt(), crearIt()$>$ \Comment{$\Ode{1}$}
    \State e.quienOcupa$_{[prx.X]}$ $_{[prx.Y]}$ $\gets$ $<$true, $"$agente", itA, crearIt()$>$ \Comment{$\Ode{1}$}
    \State var itConj(posicion) $\gets$ crearIt(vecinos(e.campus, prx)) \Comment{$\Ode{1}$}
    \While {haySiguiente(it)} \Comment{$\Ode{1}$}
    	\If {ocupada(e.campus, siguiente(it)) $\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?}
    		\State avanzar(it)	\Comment{$\Ode{1}$}
    	\Else
    		\If {esEstudiante(e, siguiente(it)) $\wedge$ esCapturable(e, siguiente(it))} \Comment{$\Ode{1}$}
    			\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
    			\While {haySiguiente(itAg)}  \Comment{$\Ode{1}$}
    				\If {esAgente(e,siguiente(itAg))}  \Comment{$\Ode{1}$}
    					\State sancionar(e, siguiente(itAg))  \Comment{$\Ode{1}$}
    				\EndIf
	    			\State avanzar(itAg)	\Comment{$\Ode{1}$}
    			\EndWhile
    		\Else
    			\If {esHippie(e,siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))}  \Comment{$\Ode{1}$}
    				\State capturarHippie(e, siguiente(it))  \Comment $\Ode{\vert Nm \vert}$
    			\EndIf
    		\EndIf
    	\EndIf	
    	\State avanzar(it)	\Comment{$\Ode{1}$}
    \EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$moverHippie}}{\paramInOut{e}{estr} \paramIn{h}{nombre}}{} \Comment{$\Ode{\vert Nm \vert}$ + $\Ode{Ne}$}
	\State var posicion actual $\gets$ obtener(e.posCiviles, h) \Comment{$\Ode{\vert Nm \vert}$}
	\State var direccion d $\gets$ proxPosicionH(e,h) \Comment{$\Ode{Ne}$}
	\State var posicion prx $\gets$ proxPosicion(e.campus, d, obtener(e.posCiviles,h)) \Comment{$1$}
	\State definir(e.posCiviles, h, prx) \Comment{$\Ode{\vert Nm \vert}$}
	\State var itConj(nombre) itR $\gets$ e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$.hayHoe \Comment{$\Ode{1}$}
	\State eliminarSiguiente(siguiente(itR).posActual) \Comment{$\Ode{1}$}
	\State siguiente(itR).posActual $\gets$ definirRapido(e.posRapida, h, prx) \Comment{$\Ode{1}$}
	\State e.quienOcupa$_{[prx.X]}$ $_{[prx.Y]}$ $\gets$ $<$true, "hippie", crearIt(), itR$>$ \Comment{$\Ode{1}$}
	\State e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$ $\gets$ $<$false, "nadie", crearIt(), crearIt()$>$ \Comment{$\Ode{1}$}
	\While {haySiguiente(it)}
		\If {ocupada(e.campus, siguiente(it)) $\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?} \Comment{$\Ode{1}$}
			\State avanzar(it)	\Comment{$\Ode{1}$}
		\Else
			\If {esEstudiante(e,siguiente(it)) $\wedge$ esHippizable(e, siguiente(it))} \Comment{$\Ode{1}$}
				\State hippizar(e, siguiente(it)) \Comment{$\Ode{1}$}
						\If {esCapturable(e,siguiente(it)}
							\State capturarHippie(e,siguiente(it)) \Comment{$\Ode{\vert Nm \vert}$}
						\EndIf
			\Else
				 \If {esEstudiante(e, siguiente(it)) $\wedge$ esCapturable(e, siguiente(it))} \Comment{$\Ode{1}$}
				 	\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
				 	\While {haySiguiente(itAg)}
				 		\If {esAgente(e,siguiente(itAg))} 
				 			\State sancionar(e, siguiente(itAg))	\Comment{$\Ode{1}$}
				 		\EndIf
				 		\State avanzar(itAg)	\Comment{$\Ode{1}$}
				 	\EndWhile
				 \Else
				 	\If {esHippie(e,siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
				 		\State capturarHippie(e,siguiente(it)) \Comment{$\Ode{\vert Nm \vert}$}
				 	\EndIf
				 \EndIf
			\EndIf
		\EndIf
		\State avanzar(it)	\Comment{$\Ode{1}$}
	\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}



\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$esEstudiante}}{\paramIn{e}{estr} \paramIn{p}{posicion}}{$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
    \State res $\gets$ e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.queHay $==$ $"$estudiante"
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$esHippie}}{\paramIn{e}{estr} \paramIn{p}{posicion}}{$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
    \State res $\gets$ e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.queHay $==$ "hippie"
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$esAgente}}{\paramIn{e}{estr} \paramIn{p}{posicion}}{$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
    \State res $\gets$ e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.queHay $==$ $"$agente"
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Estudiantizar}}{\paramInOut{e}{estr} \paramIn{p}{posicion}}{} \Comment{$\Ode{1}$}
    \State var datosHoE dat $\gets$ $<$Siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoE).ID, Siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoe).posActual$>$ \Comment{$\Ode{1}$}
    \State eliminarSiguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoe) \Comment{$\Ode{1}$}
    \State var itConj(nombre) it $\gets$ agregarRapido(e.estudiantes, dat) \Comment{$\Ode{1}$}
    \State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$true, $"$estudiante", crearIt(), it$>$ \Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Hippizar}}{\paramInOut{e}{estr} \paramIn{p}{posicion}}{} \Comment{$\Ode{1}$}
    \State var datosHoE dat $\gets$ $<$Siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoE).ID, Siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoe).posActual$>$ \Comment{$\Ode{1}$}
    \State eliminarSiguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoe) \Comment{$\Ode{1}$}
    \State var itConj(nombre) it $\gets$ agregarRapido(e.hippies, dat) \Comment{$\Ode{1}$}
    \State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$true, "hippie", crearIt(), it$>$ \Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$esCapturable}}{\paramIn{e}{estr} \paramIn{p}{posicion}}{$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
    \State var itConj(posicion) it $\gets$ crearIt(vecinos(e.campus, p)) \Comment{$\Ode{1}$}        	\State var nat Contador $\gets$ 0 \Comment{$\Ode{1}$}
    \State bool hayGuardia $\gets$ false \Comment{$\Ode{1}$}
	\While {haySiguiente(it)}
		\If {e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.ocupada?} \Comment{$\Ode{1}$}
			\State contador$+$ $+$ \Comment{$\Ode{1}$}
		\EndIf
		\If {e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.quienOcupa== $"$agente" } \Comment{$\Ode{1}$}
   			\State  hayGuardia $\gets$ true \Comment{$\Ode{1}$}
   		\EndIf
   		\State avanzar(it)	\Comment{$\Ode{1}$}
   	\EndWhile
   	\State res $\gets$ contador == 4 $\wedge$ hayGuardia \Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$esHippizable}}{\paramInOut{e}{estr} \paramIn{p}{posicion}}{$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
    \State var itConj(posicion) it $\gets$ crearIt(vecinos(e.campus, p)) \Comment{$\Ode{1}$}        	\State var nat Contador $\gets$ 0 \Comment{$\Ode{1}$}
    \While {haySiguiente(it)} \Comment{$\Ode{1}$}
    	\If {e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.quienOcupa == "hippie"} \Comment{$\Ode{1}$}
    		\State contador $+$ $+$ \Comment{$\Ode{1}$}
    	\EndIf
    	\State avanzar(it)	\Comment{$\Ode{1}$}
     \EndWhile
    \State res $\gets$ contador $\geqslant$ 2 \Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$capturarHippie}}{\paramInOut{e}{estr} \paramIn{p}{posicion}}{} \Comment{$\Ode{\vert Nm \vert}$}
    \State var nombre n $\gets$ siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoE).ID \Comment{$\Ode{1}$}
    \State eliminarSiguiente(siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoE).posActual) \Comment{$\Ode{1}$}
    \State eliminarSiguiente(siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoE) \Comment{$\Ode{1}$}
    \State borrar(n, e.posCiviles) \Comment{$\Ode{\vert Nm \vert}$}
	\State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$false, nadie, crearIt(), crearIt() $>$ \Comment{$\Ode{1}$}
	 \While {haySiguiente(it)} \Comment{$\Ode{1}$}
    	\If {e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.quienOcupa == $"$agente"} \Comment{$\Ode{1}$}
    		\State recompensar(e, siguiente(it)) \Comment{$\Ode{1}$}
    	\EndIf
    	\State avanzar(it)	\Comment{$\Ode{1}$}
     \EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$todasOcupadas}}{\paramIn{e}{estr}, \paramIn{p}{conj(posicion)}}{$\disFlechas$ res:bool} \Comment{$\Ode{1}$}
	\State var itConj(posicion) it $\gets$ crearIt(p) \Comment{$\Ode{1}$}
	\State var contador $\gets$ 0 \Comment{$\Ode{1}$}
	\While {haySiguiente(it)}
		\If {e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?} \Comment{$\Ode{1}$}
		    \State contador $+$ $+$ \Comment{$\Ode{1}$}
		\EndIf
	\EndWhile
	\State res $\gets$ contador == 4	\Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}	
	

\begin{algorithmic}[H]
\begin{algorithm}
\Function{\textsc{$i$Recompensar}}{\paramInOut{e}{estr}, \paramIn{a}{posicion}}{} \Comment{$\Ode{1}$}
	\State var placa p $\gets$ siguienteClave(quienOcupa$_{[a.X]}$ $_{[a.Y]}$.hayCana \Comment{$\Ode{1}$}
	\State var datosAgente dat $\gets$ obtener(e.agentes,p) \Comment{$\Ode{1}$}
	\State dat.premios $\gets$ dat.premios$+$1 \Comment{$\Ode{1}$}
	\If {dat.premios $>$ obtener(e.agentes, siguienteClave(e.masVigilante)).premios} \Comment{$\Ode{1}$}
		\State e.masVigilante $\gets$ quienOcupa$_{[a.X]}$ $_{[a.Y]}$.hayCana \Comment{$\Ode{1}$}
	\Else
		\If {dat.premios $==$ obtener(e.agentes, siuienteClave(e.masVigilante)).premios} \Comment{$\Ode{1}$}
			\If {p $<$ siguienteClave(e.masVigilante))} \Comment{$\Ode{1}$}
				\State e.masVigilante $\gets$ quienOcupa$_{[a.X]}$ $_{[a.Y]}$.hayCana \Comment{$\Ode{1}$}
			\EndIf
		\EndIf
	\EndIf
\EndFunction
\end{algorithm}
\end{algorithmic}

\begin{algorithmic}[H]
\begin{algorithm}
\Function{\textsc{$i$Sancionar}}{\paramInOut{e}{estr}, \paramIn{a}{posicion}}{} \Comment{$\Ode{1}$}
	\State var placa p $\gets$ siguienteClave(quienOcupa$_{[a.X]}$ $_{[a.Y]}$.hayCana \Comment{$\Ode{1}$}
	\State var datosAgente dat $\gets$ obtener(e.agentes,p) \Comment{$\Ode{1}$}
	\State dat.Qsanciones $\gets$ dat.Qsanciones$+$1 \Comment{$\Ode{1}$}
	\State eliminarSiguiente(dat.grupoSanciones)  \Comment{$\Ode{1}$}
	\State avanzar(dat.verK)  \Comment{$\Ode{1}$}
	\State e.hayNuevas $\gets$ true  \Comment{$\Ode{1}$}
	\If {Siguiente(dat.verK).K == dat.Qsanciones} \Comment{$\Ode{1}$}
		\State dat.grupoSanciones $\gets$ Agregar(siguiente(dat.verK).grupoK, p)  \Comment{$\Ode{1}$}
	\Else
		\State dat.grupoSanciones $\gets$ AgregarComoAnterior(dat.verK, $<$dat.Qsanciones,Agregar(Vacio(),p)$>$) \Comment{$\Ode{1}$}
	\EndIf
\EndFunction
\end{algorithm}
\end{algorithmic}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$ProxPosicionH}}{\paramInOut{e}{estr} \paramIn{h}{nombre}}{} \Comment{$\Ode{N_{e}}$}
	\State var itConj(datosHoE) it$\gets$ crearIt(e.estudiantes) \Comment{$\Ode{1}$}
	\State var posicion menorD $\gets$ obtener(e.posRapida,h)	\Comment{$\Ode{N_{e}}$}
	\State var direccion direcc \Comment{$\Ode{1}$}
	\If {($\neg$ haySiguiente(it)) } \Comment{$\Ode{1}$}
		\If { (menorD.Y $\leq$ e.campus.filas/2) } \Comment{$\Ode{1}$}
			\If { ($\neg$ ocupadaD(e,p,abajo)) } \Comment{$\Ode{1}$}
				\State res$\gets$Abajo \Else \Comment{$\Ode{1}$}
				\If { ($\neg$ ocupadaD(e,p,derecha)) } \Comment{$\Ode{1}$}
					\State res$\gets$Derecha \Else \Comment{$\Ode{1}$}
					\If { ($\neg$ ocupadaD(e,p,izquierda)) } \Comment{$\Ode{1}$}
						\State res$\gets$izquierda \Else \Comment{$\Ode{1}$}
						\State res$\gets$arriba \Comment{$\Ode{1}$}
					\EndIf
				\EndIf
			\EndIf
		\Else
			\If {($\neg$ ocupadaD(e,p,Arriba)) } \Comment{$\Ode{1}$}
				\State res$\gets$Arriba \Else \Comment{$\Ode{1}$}
				\If {($\neg$ ocupadaD(e,p,derecha)) } \Comment{$\Ode{1}$}
					\State res$\gets$Derecha \Else \Comment{$\Ode{1}$}
					\If {($\neg$ ocupadaD(e,p,izquierda)) } \Comment{$\Ode{1}$}
						\State res$\gets$izquierda \Else \Comment{$\Ode{1}$}
						\State res$\gets$Abajo \Comment{$\Ode{1}$}
					\EndIf
				\EndIf
			\EndIf
		\EndIf
	\Else
		\State menorD$\gets$SiguienteSignificado(siguiente(it).posActual) \Comment{$\Ode{1}$}
		\State var posicion otraPos \Comment{$\Ode{1}$}
		\While{haySiguiente(it)} \Comment{$\Ode{\longitud{N_{e}}}$}
			\State otraPos$\gets$SiguienteSignificado(siguiente(it).posActual) \Comment{$\Ode{1}$}
			\If {(distancia(e,p,otraPos) $<$ distancia(e,p,menorD)) } \Comment{$\Ode{1}$}
				\State menorD$\gets$otraPos \Comment{$\Ode{1}$}
			\EndIf
		\EndWhile
		\State res$\gets$VecinoMasCercanoA(e,p,menorD) \Comment{$\Ode{1}$}
	\EndIf	
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$ProxPosicionA}}{\paramInOut{e}{estr} \paramIn{a}{placa}}{} \Comment{$\Ode{N_{h}}$}
	\State var itConj(datosHoe) it $\gets$  crearIt(e.hippies) \Comment{$\Ode{1}$}
	\State var posicion menorD  $\gets$  obtener(e.posRapida,a) \Comment{$\Ode{N_{h}}$}
	\State var direccion direcc \Comment{$\Ode{1}$}
	\If{ ($\neg$ haySiguiente(it)) } \Comment{$\Ode{1}$}
		\If{ (menorD.Y $\leq$ e.campus.filas/2) } \Comment{$\Ode{1}$}
			\If{ ($\neg$ ocupadaD(e,p,abajo)) } \Comment{$\Ode{1}$}
				\State res $\gets$ Abajo \Else \Comment{$\Ode{1}$}
				\If{ ($\neg$ ocupadaD(e,p,derecha)) } \Comment{$\Ode{1}$}
					\State res $\gets$ Derecha \Else \Comment{$\Ode{1}$}
					\If{ ($\neg$ ocupadaD(e,p,izquierda)) } \Comment{$\Ode{1}$}
						\State res $\gets$ izquierda \Else \Comment{$\Ode{1}$}
						\State res $\gets$ arriba \Comment{$\Ode{1}$}
					\EndIf
				\EndIf
			\EndIf
		\Else 
			\If{ ($\neg$ ocupadaD(e,p,Arriba)) } \Comment{$\Ode{1}$}
				\State res $\gets$ Arriba \Else \Comment{$\Ode{1}$}
				\If{ ($\neg$ ocupadaD(e,p,derecha)) } \Comment{$\Ode{1}$}
					\State res $\gets$ Derecha \Else \Comment{$\Ode{1}$}
					\If{ ($\neg$ ocupadaD(e,p,izquierda)) } \Comment{$\Ode{1}$}
						\State res $\gets$ izquierda \Else \Comment{$\Ode{1}$}
						\State res $\gets$ Abajo \Comment{$\Ode{1}$}
					\EndIf
				\EndIf
			\EndIf
		\EndIf
	\Else
		\State menorD $\gets$ siguiente(it) \Comment{$\Ode{1}$}
		\State var posicion otraPos \Comment{$\Ode{1}$}
		\While{haySiguiente(it)} \Comment{$\Ode{\longitud{N_{h}}}$}
			\State otraPos $\gets$ SiguienteSignificado(siguiente(it).posActual) \Comment{$\Ode{1}$}
			\If{(distancia(e,p,otraPos)$<$distancia(e,p,menorD)) } \Comment{$\Ode{1}$}
				\State menorD $\gets$ otraPos \Comment{$\Ode{1}$}
			\EndIf
		\EndWhile
		\State res $\gets$ VecinoMasCercanoA(e,p,menorD)	 \Comment{$\Ode{1}$}
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$VecinoMasCercano}}{\paramIn{e}{estr} \paramIn{p}{posicion} \paramIn{p2}{posicion} } {$\disFlecha$ res : direccion} \Comment{$\Ode{1}$}
	\State var conj(posicion) Ps $\gets$ vecinos(e.campus, p) \Comment{$\Ode{1}$}
	\State var itConj(posicion) it $\gets$ crearIt(Ps) \Comment{$\Ode{1}$}
	\State var posicion destino$\gets$ siguiente(it) \Comment{$\Ode{1}$}
	\While{haySiguiente(it)} \Comment{$\Ode{1}$}
		\If{($\neg$e.quienOcupa[siguiente(it).X][siguiente(it).Y].ocupada?)} \Comment{$\Ode{1}$}
			\If{(distancia(e,p,siguiente(it))$<$distancia(e,p,destino))} \Comment{$\Ode{1}$}
				\State destino$\gets$ siguiente(it) \Comment{$\Ode{1}$}
			\EndIf
		\EndIf
		\State avanzar(it) \Comment{$\Ode{1}$}
	\EndWhile
	\If{(destino.X$\neq$p.X) } \Comment{$\Ode{1}$}
		\If{(destino.y$>$p.Y) } \Comment{$\Ode{1}$}
			\State res$\gets$ Arriba \Else \Comment{$\Ode{1}$}
			\State res$\gets$ Abajo \Comment{$\Ode{1}$}
		\EndIf
	\Else
		\If{(destino.x$>$p.x) } \Comment{$\Ode{1}$}
			\State res$\gets$ Derecha \Else \Comment{$\Ode{1}$}
			\State res$\gets$ Izquierda \Comment{$\Ode{1}$}
		\EndIf
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$SeFue}}{\paramIn{e}{estr} \paramIn{p}{posicion} \paramIn{destino}{posicion} } {$\disFlecha$ res : bool} \Comment{$\Ode{1}$}

	\State res $\gets$ (p.Y$==$e.campus.alto $-$1 $\wedge$ destino.y$==$e.campus.alto) $\vee$(p.Y$==$0 && destino.y$==-$1) \Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$BusquedaBin}}{\paramIn{v}{vector(datosK)} \paramIn{obj}{nat}} {$\disFlecha$ res : nat} \Comment{$\Ode{log_{2}(longitud(v))}$}
	\State var int i$\gets$ 0 \Comment{$\Ode{1}$}
	\State var int d$\gets$ longitud(v)-1 \Comment{$\Ode{1}$}
	\While{(i $+1<$ d)}\Comment{$\Ode{log_{2}(longitud(v))}$}
		\State var int m$\gets$  (i$+$d)$/2$ \Comment{$\Ode{1}$}
		\If{(v[m].k$<$obj)} \Comment{$\Ode{1}$}
			\State i$\gets$ m \Else \Comment{$\Ode{1}$}
			\State d$\gets$ m \Comment{$\Ode{1}$}
		\EndIf
	\EndWhile
	\If{(v[i].k$==$obj)} \Comment{$\Ode{1}$}
		\State res$\gets$ i \Else \Comment{$\Ode{1}$}
		\State res$\gets$ d \Comment{$\Ode{1}$}
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$ocupadaD}}{\paramIn{e}{rastr} \paramIn{p}{posicion} \paramIn{dir}{direccion}} {$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
\If{dir$==$ `` Arriba"}\Comment{$\Ode{1}$}
	\State res$\gets$e.quienOcupa[p.X][p.Y $+1$].ocupada? \Else \Comment{$\Ode{1}$}
	\If{dir$==$ `` Abajo"}\Comment{$\Ode{1}$}
		\State res$\gets$e.quienOcupa[p.X][p.Y $-1$].ocupada? \Else \Comment{$\Ode{1}$}
		\If{dir$==$ `` izquierda"} \Comment{$\Ode{1}$}
			\State res$\gets$e.quienOcupa[p.X$-1$][p.Y].ocupada? \Else \Comment{$\Ode{1}$}
			\State res$\gets$e.quienOcupa[p.X$+1$][p.Y].ocupada? \Comment{$\Ode{1}$}
		\EndIf
	\EndIf
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}