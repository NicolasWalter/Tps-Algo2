% Diseño del tipo T
\newpage

% Diseño del Tipo
\disDisenio{Rastrillaje}
% La especificación
\disEspecificacion
\hspace*{\disSubSecMargen}Se usa el {\sc Tad CampusSeguro} especificado por la c\'atedra.

\disAspectosDeLaInterfaz

\disInterfaz

\disSeExplicaCon{CampusSeguro}

\disGenero{rastr}

\disOperaciones{b\'asicas de Rastrillaje}

\disDeclaraFuncion{Campus}{\paramIn{r}{rastr}}{res : campus}{true}{res $\igobs$ campus(r)}{\Ode{1}}{Devuelve el campus.}

\disDeclaraFuncion{Estudiantes}{\paramIn{r}{rastr}}{res : conj(nombre)}{true}{res $\igobs$ estudiantes(r)}{\Ode{1}}{Devuelve el conjunto de estudiantes presentes en el campus.}

\disDeclaraFuncion{Hippies}{\paramIn{r}{rastr}}{res : conj(nombre)}{true}{res $\igobs$ hippies(r)}{\Ode{1}}{Devuelve el conjunto de hippies presentes en el campus.}

\disDeclaraFuncion{Agentes}{\paramIn{r}{rastr}}{res : conj(agente)}{true}{res $\igobs$ agentes(r)}{\Ode{1}}{Devuelve el conjunto de agentes presentes en el campus.}

\disDeclaraFuncion{PosEstudianteYHippie}{\paramIn{r}{rastr}, \paramIn{id}{nombre}}{res : posicion}{id $\in$ (estudiantes(r) $\cup$ hippies(cs))}{res $\igobs$ posEstudianteYHippie(id,r)}{\Ode{1}}{Devuelve la posici\'on del estudiante/hippie pasado como par\'ametro.}

\disDeclaraFuncion{PosAgente}{\paramIn{r}{rastr}, \paramIn{a}{agente}}{res : posicion}{a $\in$ posAgente(a,r)}{res $\igobs$ posAgente(a,r)}{\Ode{1}}{Devuelve la posici\'on del agente pasado como par\'ametro.}

\disDeclaraFuncion{CantSanciones}{\paramIn{r}{rastr}, \paramIn{a}{agente}}{res : nat}{a $\in$ cantSanciones(a,r)}{res $\igobs$ cantSanciones(a,r)}{\Ode{1}}{Devuelve la cantidad de sanciones recibidas por el agente pasado como par\'ametro.}

\disDeclaraFuncion{CantHippiesAtrapados}{\paramIn{r}{rastr}, \paramIn{a}{agente}}{res : nat}{a $\in$ agentes(r)}{res $\igobs$ cantHippiesAtrapados(a,r)}{\Ode{1}}{Devuelve la cantidad de hippies atrapados por el agente pasado como par\'ametro.}

\disDeclaraFuncion{ComenzarRastrillaje}{\paramIn{c}{campus}, \paramIn{d}{dicc(agente,posicion)}}{res : rastr}{($\forall$ a : agente)(def?(a,d) $\impluego$ (posValida?(obtener(a,d))) $\land$ $\¬$ocupada?(obtener(a,d),c)) $\land$ ($\forall$ a, $a_{2}$ : agente)((def?(a,d) $\land$ def?($a_{2}$,d) $\land$ a $\not=a_{2}$) $\impluego$ obtener(a,d)$\not=$ obtener($a_{2}$,d))}{res $\igobs$ comenzarRastrillaje(c,d)}{\Ode{1}}{Crea un Rastrillaje.}

\disDeclaraFuncion{IngresarEstudiante}{\paramInOut{r}{rastr}, \paramIn{e}{nombre}, \paramIn{p}{posicion}}{}{r = $r_{0}$ $\land$ e $\notin$ (estudiantes(r)$\cup$hippies(r)) $\land$ esIngreso?(p,campus(r)) $\land$ $\¬$estaOcupada?(p,r)}{r $\igobs$ ingresarEstudiante(e,p,$r_{0}$)}{\Ode{1}}{Modifica el rastrillaje, ingresando un estudiante al campus.}

\disDeclaraFuncion{IngresarHippie}{\paramInOut{r}{rastr}, \paramIn{h}{nombre}, \paramIn{p}{posicion}}{}{r = $r_{0}$ $\land$ h $\notin$ (estudiantes(r)$\cup$hippies(r)) $\land$ esIngreso?(p,campus(r)) $\land$ $\¬$estaOcupada?(p,r)}{r $\igobs$ ingresarHippie(h,p,$r_{0}$)}{\Ode{1}}{Modifica el rastrillaje, ingresando un hippie al campus.}

\disDeclaraFuncion{MoverEstudiante}{\paramInOut{r}{rastr}, \paramIn{e}{nombre}, \paramIn{dir}{direccion}}{}{r = $r_{0}$ $\land$ e $\in$ estudiantes(r) $\land$ (seRetira(e,dir,r) $\lor$ (posValida?(proxPosicion(posEstudianteYHippie(e,r),dir,campus(r)),campus(r)) $\land$ $\¬$estaOcupada?(proxPosicion(posEstudianteYHippie(e,r),dir,campus(r)),r)))}{r $\igobs$ moverEstudiante(e,d,$r_{0}$)}{\Ode{1}}{Modifica el rastrillaje, al mover un estudiante del campus.}

\disDeclaraFuncion{MoverHippie}{\paramInOut{r}{rastr}, \paramIn{h}{nombre}}{}{r = $r_{0}$ $\land$ h $\in$ hippies(r) $\land$ $\¬$todasOcupadas?(vecinos(posEstudianteYHippie(h,r),campus(r)),r) }{r $\igobs$ moverHippie(r,$r_{0}$)}{\Ode{1}}{Modifica el rastrillaje, al mover un hippie del campus.}

\disDeclaraFuncion{MoverAgente}{\paramInOut{r}{rastr}, \paramIn{a}{agente}}{}{r = $r_{0}$ $\land$ a $\in$ agentes(r) $\yluego$ cantSanciones(a,r) $\leq$ 3 $\land$ $\¬$todasOcupadas?(vecinos(posAgente(a,r),campus(r)),r)}{r $\igobs$ moverAgente(a,$r_{0}$)}{\Ode{1}}{Modifica el rastrillaje, al mover un agente del campus.}

\disDeclaraFuncion{MasVigilante}{\paramIn{r}{rastr}}{res : agente}{true}{res $\igobs$ masVigilante(r)}{\Ode{1}}{Devuelve el agente con mas capturas.}

\disDeclaraFuncion{ConKSanciones}{\paramIn{r}{rastr}, \paramIn{k}{nat}}{res : conj(agente)}{true}{res $\igobs$ conKSanciones(k,r)}{\Ode{1}}{Devuelve el agente con mas capturas.}

\disDeclaraFuncion{ConMismasSanciones}{\paramIn{r}{rastr}, \paramIn{a}{agente}}{res : conj(agente)}{a $\in$ agentes(r)}{res $\igobs$ conMismasSanciones(a,r)}{\Ode{1}}{Devuelve el conjunto de agentes con la misma cantidad de sanciones que a.}





\disPautasDeImplementacion

\disEstructuraDeRepresentacion

\disSeRepresentaCon{campus}{estr}
\disDondeEs{estr}{\disTuplaEstr{campus/campo, diccPromedio(agente ; datosAg)/agentes, arreglo(tupla(placa;posicion))/posAgentesLog, conjLineal(datosHoE)/hippies, conjLineal(datosHoE)/estudiantes, diccString(nombre;posicion)/posCiviles, diccLineal(nombre;posicion)/posRapida, vector(vector(datosPos))/quienOcupa, itConj(agente)/masVigilante, lista(datosK))/agregoEn1, vector(datosK)/buscoEnLog}}

\disDondeEs{datosAg}{\disTuplaEstr{nat/QSanciones, nat/premios, posicion/posActual, itConj(agente)/grupoSanciones, itLista(datosK)/verK}}

\disDondeEs{datosHoE}{\disTuplaEstr{nombre/ID, itDicc(nombre;posicion)/posActual}}

\disDondeEs{datosPos}{\disTuplaEstr{bool/ocupada?, clases/queHay, itDicc(agente)/hayCana, itConj(nombre)/hayHoE}}

\disDondeEs{clases}{enum\{``agente'',``estudiante'',``hippie'',``obstaculo'',``nada''\}}

\disDondeEs{datosK}{\disTuplaEstr{nat/K, conjLineal(agente)/grupoK}}

\disJustificacionDeLaEstructuraElegida
\newpage
\disInvarianteDeRepresentacion
\hspace*{\disSubSubSecMargen}\textbf{\textsf{Informal}}

\hspace*{\disSubSubSecMargen}
\begin{enumerate}
\setlength{\itemindent}{3em}
  \item El mapa debe tener tantas filas como indica la estructura, lo mismo con las columnas.

\end{enumerate}

\hspace*{\disSubSubSecMargen}\textbf{\textsf{Formal}}
\onehalfspace
\disRep{estr}{e}{$true$ $\Longleftrightarrow$ 
\\\hspace*{3.75em}(1)(2)(3) ($\forall$ a,a2: Agente)(def?(a,e.agentes) $\wedge$ def?(a2,e.agentes)) $\impluego$ \\ (obtener(a,e.agentes).Qsanciones=siguiente(obtener(a,e.agentes).verK).K \\ $\wedge$ obtener(a,e.agentes).grupoSanciones=siguiente(obtener(a,e.agentes).verK).grupoK \\ $\wedge$ (a2 $\in$ obtener(a,e.agentes).grupoSanciones) $\Longleftrightarrow$ (obtener(a,e.agentes).Qsanciones = obtener(a2,e.agentes).Qsanciones) $\wedge$ (4) PosValida(e,obtener(a,e.agentes).PosActual)) $\wedge$ (5) TodasLasPlacas(e,e.PosAgentesLog())}
\disFuncionDeAbstraccion
\vspace*{-1em}
%\hspace*{\disSubSubSecMargen}{Texto}
\disAbs{estr}{e}{campus}{c}{\Big(filas(c) = e.filas $\land$ columnas(c) = e.columnas $\yluego$ ($\forall$ p : posicion)(p.X $\leq$ e.filas $\land$
\\\hspace*{3.75em} p.Y $\leq$ e.columnas $\impluego$ ocupada?(p,c) $\Leftrightarrow$ (e.mapa[f])[c]\Big) }


%\disFuncionDeAbsFuncionesAux


\newpage

\disAlgoritmos
%\hspace*{\disSubSubSecMargen}{Texto}
% HACK: SGA 28/05/2011. Para quitar el titulo Algorithm del caption \floatname{algorithm}{}
\floatname{algorithm}{}
% WARNING: SGA 27/05/2011. La opción [H] indica a LaTex que el algoritmo lo queremos AQUI!
% Ver 4.4.1 Placement of Algorithms de algorithms.pdf.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Campus}}{\paramIn{e}{estr}}{$\disFlecha$ res : campus} \Comment{$\Ode{1}$}
  \State res $\gets$ e.campo
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Estudiantes}}{\paramIn{e}{estr}}{$\disFlecha$ res : itConj(nombre)} \Comment{$\Ode{1}$}
  \State res $\gets$ crearIt (e.estudiantes)
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Hippies}}{\paramIn{e}{estr}}{$\disFlecha$ res : itConj(nombre)} \Comment{$\Ode{1}$}
  \State res $\gets$ crearIt (e.hippies)
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Agentes}}{\paramIn{e}{estr}}{$\disFlecha$ res : itConj(agente)} \Comment{$\Ode{1}$}
  \State res $\gets$ crearIt (e.agentes) 
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$posEstudiantesYHippie}}{\paramIn{n}{nombre} \paramIn{e}{estr}}{$\disFlecha$ res : posicion} \Comment{$\Ode{\longitud{n_{m}}}$}
    \State res $\gets$ obtener(n,e.posCiviles)
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$posAgente}}{\paramIn{a}{agente} \paramIn{e}{estr}}{$\disFlecha$ res : posicion} \Comment{$\Ode{1}(promedio)$}
    \State res $\gets$ obtener(a,e.agentes).posActual
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$cantSanciones}}{\paramIn{a}{agente} \paramIn{e}{estr}}{$\disFlecha$ res : nat} \Comment{$\Ode{1}(promedio)$}
    \State res $\gets$ obtener(a,e.agentes).Qsanciones
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$cantHippiesAtrapados}}{\paramIn{a}{agente} \paramIn{e}{estr}}{$\disFlecha$ res : nat} \Comment{$\Ode{1}(promedio)$}
    \State res $\gets$ obtener(a,e.agentes).premios
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$masVigilante}}{\paramIn{r}{rastr}}{$\disFlecha$ res : agente} \Comment{$\Ode{1}$}
    \State res $\gets$ siguiente(e.masVigilante)
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$conMismasSanciones}}{\paramIn{r}{rastr} \paramIn{a}{agente}}{$\disFlecha$ res : conj(agente)} \Comment{$\Ode{1}$}
    \State res $\gets$ siguiente(obtener(e.agentes,a).grupoSanciones)
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$conKSanciones}}{\paramIn{r}{rastr} \paramIn{k}{nat}}{$\disFlecha$ res : conj(agente)} \Comment{$\Ode{n}$ la primera vez, luego mientras no haya sanciones $\Ode{log n}$}
	\If {$\neg$e.huboNuevas} \Comment{$\Ode{1}$}
		 \State var nat i $\gets$ BusquedaBin(e.buscoEnLog, k) \Comment{$\Ode{log n}$}
		 \State res $\gets$ e.buscoEnLog$_{[i]}$.grupoK \Comment{$\Ode{1}$}
	\Else
		 \State var itLista(datosK) itK $\gets$ crearIt(e.agregoEn1) \Comment{$\Ode{1}$}
		 \While {haySiguiente(it)} \Comment{$\Ode{1}$}
		 	\State buscoEnLog $_{[i]}$ $\gets$ siguiente(itK) \Comment{$\Ode{1}$}
		 	\State avanzar(itK)
		 \EndWhile
		 \State var nat i $\gets$ BusquedaBin (e.buscoEnLog, k) \Comment{$\Ode{log n}$}
		 \State res $\gets$ e.buscoEnLog$_{[i]}$.grupoK \Comment{$\Ode{1}$}
		 \State e.hayNuevas $\gets$ false \Comment{$\Ode{1}$}
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$ingresarHippie}}{\paramInOut{r}{rastr} \paramIn{p}{posicion} \paramIn{h:nombre}}{} \Comment{$\Ode{\vert Nm \vert}$}
	\State definir(e.posCiviles, h,p) \Comment{$\Ode{\vert Nm \vert}$}
	\State var itDicc(nombre,posicion) iterPos $\gets$ definirRapido(e.posRapida,h,p) \Comment{$\Ode{1}$}
	\State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$ true, "hippie", crearIt(), agregarRapido(e.hippies,$<$h,iterPos$>$)$>$ \Comment{$\Ode{1}$}
	\State var conj(posicion) Ps $\gets$ vecinos(e.campus,p) \Comment{$\Ode{1}$}
	\State var itConj(posicion) $\gets$ crearIt(ps) \Comment{$\Ode{1}$}
	\If {esCapturable(e,p)} \Comment{$\Ode{1}$}
		\State capturarHippie(e,p) \Comment{$\Ode{\vert Nm \vert}$}
	\Else
		\While {haySiguiente(it)} \Comment{$\Ode{1}$}
			\If {ocupada(e.campus, siguiente(it)) $\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?} \Comment{$\Ode{1}$}
				\State avanzar(it) \Comment{$\Ode{1}$}
			\Else
				\If {esEstudiante(e,siguiente(it)) $\wedge$ esHippizable(e,siguiente(it))} \Comment{$\Ode{1}$}
					\State Hippizar(e, siguiente(it)) \Comment{$\Ode{1}$}
					\If {esCapturable(e,siguiente(it)}	 \Comment{$\Ode{1}$}
						\State capturarHippie(e,siguiente(it))  \Comment{$\Ode{\vert Nm \vert}$}
					\EndIf 
				\Else 
					\If {esEstudiante(e,siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
						\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
						\While {haySiguiente(itAg)} \Comment{$\Ode{1}$}
							\If {esAgente(siguiente(itAg)} \Comment{$\Ode{1}$}
								\State sancionar(e,siguiente(itAg)) \Comment{$\Ode{1}$}
							\EndIf
							\State avanzar(itAg)
						\EndWhile
   					 \EndIf
				\EndIf
			\EndIf
			\State avanzar(it)
		\EndWhile
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$moverEstudiante}}{\paramInOut{r}{rastr}, \paramIn{d}{direccion}, \paramIn{s}{estudiante}} \Comment{$\Ode{\vert Nm \vert}$}
	\State actual $\gets$ obtener(e.posCiviles,s)  \Comment{$\Ode{1}$}
	\State prx $\gets$ proxPosicion(e.campus, d, actual)  \Comment{$\Ode{1}$}
	\If {seFue?(e.campus,actual, prx)}
		\State borrar(e.posCiviles, s) \Comment{$\Ode{\vert Nm \vert}$}
		\State var itConj(datosHoE) dat $\gets$ copia(e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$.hayHoE) \Comment{$\Ode{1}$}
		\State eliminarSiguiente(dat, posActual) \Comment{$\Ode{1}$}
		\State eliminarSiguiente(dat) \Comment{$\Ode{1}$}
		\State e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$ $\gets$ $<$ false, "nada", crearIt(), crearIt() $>$ \Comment{$\Ode{1}$}
	\Else
		\State var itConj(datosHoE) iterAHOI $\gets$ copia(e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$.hayHoE) \Comment{$\Ode{1}$}
		\State eliminarSiguiente(siguiente(iterAHOI).posActual) \Comment{$\Ode{1}$}
		\State siguiente(iterAHOI).posActual $\gets$ definirRapido(e.posRApida,s,prx) \Comment{$\Ode{1}$}
		\State e.quienOcupa$_{[prx.X]}$ $_{[prx.Y]}$ $\gets$ $<$true, " estudiante", crearIt(), iterAHOI$>$ \Comment{$\Ode{1}$}
		\State e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$ $\gets$ $<$false, "nada", crearIt(), crearIt()$>$ \Comment{$\Ode{1}$}
		\State definir(e.posCiviles, s, prx) \COmment{$\Ode{\vert Nm \vert}$}
		\State var conj(posicion) vc $\gets$ vecinos(e.campus, prx) \Comment{$\Ode{1}$}
		\State var itConj(posicion) it $\gets$ crearIt(vc) \Comment{$\Ode{1}$}
		
		\If {esHippizable(e,prx)} \Comment{$\Ode{1}$}
			\State hippizar(e, prx) \Comment{$\Ode{1}$}
			\While {haySiguiente(it} \Comment{$\Ode{1}$}
				\If {ocupada(e.campus, siguiente(it)) $\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?}
					\State avanzar(it)
				\Else \If {esEstudiante(e,siguiente(it)) $\wedge$ esHippizable(e,siguiente(it))} \Comment{$\Ode{1}$}
						 \State Hippizar(e, siguiente(it))  \Comment{$\Ode{1}$}
						 \If {esCapturable(e, siguiente(it))}  \Comment{$\Ode{1}$}
						 	\State capturarHippie(e,siguiente(it)  \Comment{$\Ode{\vert Nm \vert}$}
						 \EndIf
					  \Else \If {esEstudiante(e,siguiente(it) $\wedge$ esCapturable(e,siguiente(it)} \Comment{$\Ode{1}$}
					  			\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
					  			\While {haySiguiente(itAg)} \Comment{$\Ode{1}$}
					  				\If {esAgente(e,siguiente(itAg)} \Comment{$\Ode{1}$}
					  					\State sancionar(e,siguiente(itAg)) \Comment{$\Ode{1}$}
					  				\EndIf
					  			\State avanzar(itAg)
					  			\EndWhile
					  		\Else
					  			\If {esHippie(e,siguiente(it)) $\wedge$ esCapturable(s,siguiente(it)} \Comment{$\Ode{1}$}
					  				\State capturarHippie(e,siguiente(it))  \Comment{$\Ode{\vert Nm \vert}$}
					  			\EndIf	
					  		\EndIf
					  	\EndIf
					\EndIf
			\EndWhile
		\Else
			\While {haySiguiente(it)}
			\If {ocupada(e.campus, siguiente(it))$\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?} \Comment{$\Ode{1}$}
					\State avanzar(it)
				\Else
					\If {esHippie(e, siguiente(it)) $\wedge$ esEstudiantizable(e,siguiente(it))} \Comment{$\Ode{1}$}
						\State Estudiantizar(e, siguiente(it)) \Comment{$\Ode{1}$}
					\Else
						\If {esEstudiante(e,siguiente(it)) $\wedge$ esCapturable(e, siguiente(it))} \Comment{$\Ode{1}$}
							\State var itConj(posicion) itAg2 $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
							\While {haySiguiente(itAg2)} \Comment{$\Ode{1}$}
								\If {esAgente(e,siguiente(itAg2))} \Comment{$\Ode{1}$}
									\State sancionar(e,siguiente(itAg2)) \Comment{$\Ode{1}$}
								\EndIf
								\State avanzar(itAg2)
							\EndWhile
							\newpage
						\Else
							\If {esHippie(e, siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
								\State capturarHippie(e, siguiente(it))  \Comment{$\Ode{\vert Nm \vert}$}
							\EndIf
						\EndIf
					\EndIf
				\EndIf
				\State avanzar(it)
			\EndWhile
		\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$moverAgente}}{\paramInOut{r}{rastr} \paramIn{a}{agente}}{} \Comment{$\Ode{\vert Nm \vert}$ $+$ $\Ode{log Na}$ $+$ $\Ode{Ne}$}
    \State var nat j $\gets$ BusquedaBin(e.AgentesLog,a) \Comment{$\Ode{log n}$}
    \State var posicion actual $\gets$ e.AgentesLog$_{[j]}$ \Comment{$\Ode{1}$}
    \State var direccion d $\gets$ proxPosicionA(e,a) \Comment{$\Ode{Ne}$}
    \State var posicion prx $\gets$ proxPosicion(e.campus, d, actual) \Comment{$\Ode{1}$}
    \State var datosAg datAux $\gets$ obtener(e.agentes, a) \Comment{$\Ode{1}$}
    \State datAux.posActual $\gets$ prx \Comment{$\Ode{1}$}
    \State var itDicc(placa,datosAg) itA $\gets$ copia(e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$.hayCana) \Comment{$\Ode{1}$}
    \State e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$ $\gets$ $<$false, "nadie", crearIt(), crearIt()$>$ \Comment{$\Ode{1}$}
    \State e.quienOcupa$_{[prx.X]}$ $_{[prx.Y]}$ $\gets$ $<$true, " agente", itA, crearIt()$>$ \Comment{$\Ode{1}$}
    \State var itConj(posicion) $\gets$ crearIt(vecinos(e.campus, prx)) \Comment{$\Ode{1}$}
    \While {haySiguiente(it)} \Comment{$\Ode{1}$}
    	\If {ocupada(e.campus, siguiente(it)) $\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?}
    		\State avanzar(it)
    	\Else
    		\If {esEstudiante(e, siguiente(it)) $\wedge$ esCapturable(e, siguiente(it))} \Comment{$\Ode{1}$}
    			\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
    			\While {haySiguiente(itAg)}  \Comment{$\Ode{1}$}
    				\If {esAgente(e,sig(itAg))}  \Comment{$\Ode{1}$}
    					\State sancionar(e, siguiente(itAg))  \Comment{$\Ode{1}$}
    				\EndIf
	    			\State avanzar(itAg)
    			\EndWhile
    		\Else
    			\If {esHippie(e,siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))}  \Comment{$\Ode{1}$}
    				\State capturarHippie(e, siguiente(it))  \Comment $\Ode{\vert Nm \vert}$
    			\EndIf
    		\EndIf
    	\EndIf	
    	\State avanzar(it)
    \EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}