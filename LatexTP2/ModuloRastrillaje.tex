% Diseño del tipo T
\newpage

% Diseño del Tipo
\disDisenio{Rastrillaje}
% La especificación
\disEspecificacion
\hspace*{\disSubSecMargen}Se usa el {\sc Tad CampusSeguro} especificado por la c\'atedra.

\disAspectosDeLaInterfaz

\disInterfaz

\disSeExplicaCon{CampusSeguro}

\disGenero{rastr}

\disOperaciones{b\'asicas de Rastrillaje}

\disDeclaraFuncion{Campus}{\paramIn{r}{rastr}}{res : campus}{true}{res $\igobs$ campus(r)}{\Ode{1}}{Devuelve el campus.}

\disDeclaraFuncion{Estudiantes}{\paramIn{r}{rastr}}{res : conj(nombre)}{true}{res $\igobs$ estudiantes(r)}{\Ode{1}}{Devuelve el conjunto de estudiantes presentes en el campus.}

\disDeclaraFuncion{Hippies}{\paramIn{r}{rastr}}{res : conj(nombre)}{true}{res $\igobs$ hippies(r)}{\Ode{1}}{Devuelve el conjunto de hippies presentes en el campus.}

\disDeclaraFuncion{Agentes}{\paramIn{r}{rastr}}{res : conj(agente)}{true}{res $\igobs$ agentes(r)}{\Ode{1}}{Devuelve el conjunto de agentes presentes en el campus.}

\disDeclaraFuncion{PosEstudiantesYHippie}{\paramIn{r}{rastr}, \paramIn{id}{nombre}}{res : posicion}{id $\in$ (estudiantes(r) $\cup$ hippies(cs))}{res $\igobs$ posEstudianteYHippie(id,r)}{\Ode{$\vert N_{m} \vert$}}{Devuelve la posici\'on del estudiante/hippie pasado como par\'ametro.}
\\
\disDeclaraFuncion{PosAgente}{\paramIn{r}{rastr}, \paramIn{a}{agente}}{res : posicion}{a $\in$ posAgente(a,r)}{res $\igobs$ posAgente(a,r)}{\Ode{1}}{Devuelve la posici\'on del agente pasado como par\'ametro. La complejidad se da en el caso promedio.}

\disDeclaraFuncion{CantSanciones}{\paramIn{r}{rastr}, \paramIn{a}{agente}}{res : nat}{a $\in$ cantSanciones(a,r)}{res $\igobs$ cantSanciones(a,r)}{\Ode{1}}{Devuelve la cantidad de sanciones recibidas por el agente pasado como par\'ametro. La complejidad se da en el caso promedio.}

\disDeclaraFuncion{CantHippiesAtrapados}{\paramIn{r}{rastr}, \paramIn{a}{agente}}{res : nat}{a $\in$ agentes(r)}{res $\igobs$ cantHippiesAtrapados(a,r)}{\Ode{1}}{Devuelve la cantidad de hippies atrapados por el agente pasado como par\'ametro. La complejidad se da en el caso promedio.}

\disDeclaraFuncion{ComenzarRastrillaje}{\paramIn{c}{campus}, \paramIn{d}{dicc(agente,posicion)}}{res : rastr}{($\forall$ a : agente)(def?(a,d) $\impluego$ (posValida?(obtener(a,d))) $\land$ $\¬$ocupada?(obtener(a,d),c)) $\land$ ($\forall$ a, $a_{2}$ : agente)((def?(a,d) $\land$ def?($a_{2}$,d) $\land$ a $\not=a_{2}$) $\impluego$ obtener(a,d)$\not=$ obtener($a_{2}$,d))}{res $\igobs$ comenzarRastrillaje(c,d)}{\Ode{1}}{Crea un Rastrillaje.}

\disDeclaraFuncion{IngresarEstudiante}{\paramInOut{r}{rastr}, \paramIn{e}{nombre}, \paramIn{p}{posicion}}{}{r = $r_{0}$ $\land$ e $\notin$ (estudiantes(r)$\cup$hippies(r)) $\land$ esIngreso?(p,campus(r)) $\land$ $\¬$estaOcupada?(p,r)}{r $\igobs$ ingresarEstudiante(e,p,$r_{0}$)}{\Ode{$\mid Nm \mid$}}{Modifica el rastrillaje, ingresando un estudiante al campus.}

\disDeclaraFuncion{IngresarHippie}{\paramInOut{r}{rastr}, \paramIn{h}{nombre}, \paramIn{p}{posicion}}{}{r = $r_{0}$ $\land$ h $\notin$ (estudiantes(r)$\cup$hippies(r)) $\land$ esIngreso?(p,campus(r)) $\land$ $\¬$estaOcupada?(p,r)}{r $\igobs$ ingresarHippie(h,p,$r_{0}$)}{\Ode{$\vert Nm \vert$}}{Modifica el rastrillaje, ingresando un hippie al campus.}

\disDeclaraFuncion{MoverEstudiante}{\paramInOut{r}{rastr}, \paramIn{e}{nombre}, \paramIn{dir}{direccion}}{}{r = $r_{0}$ $\land$ e $\in$ estudiantes(r) $\land$ (seRetira(e,dir,r) $\lor$ (posValida?(proxPosicion(posEstudianteYHippie(e,r),dir,campus(r)),campus(r)) $\land$ $\¬$ estaOcupada?(proxPosicion(posEstudianteYHippie(e,r),dir,campus(r)),r)))}{r $\igobs$ moverEstudiante(e,d,$r_{0}$)}{\Ode{$\vert Nm \vert$}}{Modifica el rastrillaje, al mover un estudiante del campus.}

\disDeclaraFuncion{MoverHippie}{\paramInOut{r}{rastr}, \paramIn{h}{nombre}}{}{r = $r_{0}$ $\land$ h $\in$ hippies(r) $\land$ $\¬$todasOcupadas?(vecinos(posEstudianteYHippie(h,r),campus(r)),r) }{r $\igobs$ moverHippie(r,$r_{0}$)}{\Ode{$\vert Nm \vert$} $+$ \Ode{Ne}}{Modifica el rastrillaje, al mover un hippie del campus.}

\disDeclaraFuncion{MoverAgente}{\paramInOut{r}{rastr}, \paramIn{a}{agente}}{}{r = $r_{0}$ $\land$ a $\in$ agentes(r) $\yluego$ cantSanciones(a,r) $\leq$ 3 $\land$ $\¬$todasOcupadas?(vecinos(posAgente(a,r),campus(r)),r)}{r $\igobs$ moverAgente(a,$r_{0}$)}{\Ode{$\vert Nm \vert$} $+$ \Ode{log Na} $+$ \Ode{Ne}}{Modifica el rastrillaje, al mover un agente del campus.}

\disDeclaraFuncion{MasVigilante}{\paramIn{r}{rastr}}{res : agente}{true}{res $\igobs$ masVigilante(r)}{\Ode{1}}{Devuelve el agente con mas capturas.}

\disDeclaraFuncion{ConKSanciones}{\paramIn{r}{rastr}, \paramIn{k}{nat}}{res : conj(agente)}{true}{res $\igobs$ conKSanciones(k,r)}{\Ode{Na} \diagup \Ode{log Na}}{Devuelve el agente con mas capturas. La primera vez que se llama ser\'a \Ode{Na} luego mientras no haya sanciones, \Ode{log Na}.}

\disDeclaraFuncion{ConMismasSanciones}{\paramIn{r}{rastr}, \paramIn{a}{agente}}{res : conj(agente)}{a $\in$ agentes(r)}{res $\igobs$ conMismasSanciones(a,r)}{\Ode{1}}{Devuelve el conjunto de agentes con la misma cantidad de sanciones que a.}





\disPautasDeImplementacion

\disEstructuraDeRepresentacion

\disSeRepresentaCon{campus}{estr}
\disDondeEs{estr}{\disTuplaEstr{campus/campo, diccPromedio(agente ; datosAg)/agentes, arreglo(tupla(placa;posicion))/posAgentesLog, conjLineal(datosHoE)/hippies, conjLineal(datosHoE)/estudiantes, diccString(nombre;posicion)/posCiviles, diccLineal(nombre;posicion)/posRapida, vector(vector(datosPos))/quienOcupa, itConj(agente)/masVigilante, lista(datosK))/agregoEn1, bool/hayNuevas, vector(datosK)/buscoEnLog}}

\disDondeEs{datosAg}{\disTuplaEstr{nat/QSanciones, nat/premios, posicion/posActual, itConj(agente)/grupoSanciones, itLista(datosK)/verK}}

\disDondeEs{datosHoE}{\disTuplaEstr{nombre/ID, itDicc(nombre;posicion)/posActual}}

\disDondeEs{datosPos}{\disTuplaEstr{bool/ocupada?, clases/queHay, itDicc(agente)/hayCana, itConj(nombre)/hayHoE}}

\disDondeEs{clases}{enum\{``agente'',``estudiante'',``hippie'',``obstaculo'',``nada''\}}

\disDondeEs{datosK}{\disTuplaEstr{nat/K, conjLineal(agente)/grupoK}}

\disJustificacionDeLaEstructuraElegida
\newpage
\disInvarianteDeRepresentacion
\hspace*{\disSubSubSecMargen}\textbf{\textsf{Informal}}

\hspace*{\disSubSubSecMargen}
\begin{enumerate}
\setlength{\itemindent}{3em}
  \item Todos los agentes tienen distinta posicion.
  \item La cantidad de sanciones se ve reflejada dos veces en la tupla DatosAg y debe ser la misma.
  \item Si dos agentes tienen la misma cantidad de sanciones, pertenecen al mismo grupo. En caso contrario, sus grupos son disjuntos.
  \item Todas las posiciones estan dentro del rango permitido en el campus.
  \item El conjunto que contiene a todas las placas de posAgentesLog es igual al conjunto de claves de agentes. 
  \item Todas las posiciones de los agentes son los significados del diccionario "agentes" y tambien se ven en "posAgentesLog" y son las mismas.
  \item La union de los gruposK pertenecientes a "agregoEn1" es igual al conjunto de claves de agentes.
  \item 
\end{enumerate}

\hspace*{\disSubSubSecMargen}\textbf{\textsf{Formal}}
\onehalfspace
\disRep{estr}{e}{$true$ $\Longleftrightarrow$ 
\\\hspace*{3.75em}(1)(2)(3)(4) ($\forall$ a,a2: Agente)(a $\neq$ a2 $\wedge$ definido?(a,e.agentes) $\wedge$ definido?(a2,e.agentes) \\ $\yluego$ PosValida(e.campo,obtener(a,e.agentes).PosActual) $\wedge$ PosValida(e.campo,obtener(a2,e.agentes).PosActual))) $\impluego$ \\ obtener(a,e.agentes).PosActual $\neq$ obtener(a2,e.agentes).PosActual \\ $\wedge $ (obtener(a,e.agentes).Qsanciones=siguiente(obtener(a,e.agentes).verK).K \\ $\wedge$ obtener(a,e.agentes).grupoSanciones=siguiente(obtener(a,e.agentes).verK).grupoK \\ $\wedge$ (a2 $\in$ obtener(a,e.agentes).grupoSanciones) $\Longleftrightarrow$ (obtener(a,e.agentes).Qsanciones = obtener(a2,e.agentes).Qsanciones) \\ $\wedge$ (5) TodasLasPlacas(e,e.posAgentesLog)= claves(e.agentes) \\ $\wedge$ (6) ($\forall$ a3:agente, t: tupla(agente,posicion))(t $\in$ e.posAgentesLog $\wedge$ a3= $\Pi_{1}$(t) $\yluego$ definido?(a3,e.agentes) $\impluego$ obtener(a3,e.agentes)= $\Pi_{2}$(t))
 \\ $\wedge$ enOrden(e.posAgentesLog) $\wedge$ enOrden(e.buscoEnLog)  \\ $\wedge$ (7) UnionConjuntos(e,e.agregoEn1)=claves(e.agentes) \\ $\wedge$ ($\forall$ h,h1:tupla(nombre,itDicc(nombre;posicion)))(h $\in$ e.hippies $\wedge$ h1 $\in$ e.hippies $\wedge$ $\Pi_{1}$(h) $\neq$ $\Pi_{1}$(h1)) $\impluego$ ($\Pi_{2}$(h) $\neq$ $\Pi_{2}$(h1)) \\
 $\wedge$ e.posCiviles=e.posRapida $\wedge$ ($\forall$ hi:nombre,e:nombre)((definido?(hi,e.posCiviles) $\wedge$ definido?(e,e.posCiviles)) $\impluego$ obtener(e,e.posCiviles) $\neq$ obtener(hi,e.posCiviles) \\$\wedge$ ($\forall$ a:agente, civ:nombre)(definido?(a,e.agentes) $\wedge$ definido?(civ,e.posCiviles)) \\ $\impluego$ (obtener(a,e.agentes) $\neq$ obtener(civ,e.posCiviles)) $\wedge$ (e.hippies $\cap$ e.estudiantes)= $\emptyset$ \\ $\wedge$ JuntarIDS(e.estudiantes)$\cup$JuntarIDS(e.hippies)=claves(e.posCiviles)) \\ $\wedge$ ($\forall$ i:nat, j:nat)(i$\geq$0 $\wedge$ i$<$e.campo.filas $\wedge$ j$\geq$0 $\wedge$ j$<$e.campo.columnas) $\impluego$ \IF $\Pi_{1}$(e.quienOcupa[i][j])=false \\ THEN $\Pi_{2}$(e.quienOcupa[i][j]) = $"nada"$ \\ ELSE \IF $\Pi_{2}$(e.quienOcupa[i][j]) = "hippie" $\vee$ $\Pi_{2}$(e.quienOcupa[i][j]) = $"estudiante"$ THEN $\Pi_{3}$(e.quienOcupa[i][j])=itvacio ELSE   $\Pi_{4}$(e.quienOcupa[i][j])=itvacio FI FI \\ $\wedge$ ($\forall$ k:nat)(($\exists$ i:nat)(i$\geq$0 $\wedge$ i$<$longitud(e.agregoEn1) $\impluego$ e.agregoEn1[i].K=k) $\Longleftrightarrow$ ($\exists$ ag:agente)(definido?(ag,e.agentes) $\impluego$ obtener(ag,e.agentes).Qsanciones=k $\wedge$ ag $\in$ e.agregoEn1[i].grupoK)) \\ $\wedge$ ($\forall$ k:nat)(($\exists$ i:nat)(i$\geq$0 $\wedge$ i$<$longitud(e.buscoEnLog) $\impluego$ e.buscoEnLog[i].K=k) $\Longleftrightarrow$ ($\exists$ ag:agente)(definido?(ag,e.agentes) $\impluego$ obtener(ag,e.agentes).Qsanciones=k $\wedge$ ag $\in$ e.buscoEnLog[i].grupoK)) } 	
\disFuncionDeAbstraccion
\vspace*{-1em}
%\hspace*{\disSubSubSecMargen}{Texto}
\disAbs{estr}{e}{rastrillaje}{c}{\Big(campus(r) = e.campo $\land$ estudiantes(r) = e.estudiantes $\land$ hippies(r)=e.hippies $\land$ agentes(r)=e.agentes \\ $\land$ ($\forall$ n:nombre)((definido?(n,posEstudianteYHippie(n,r)) $\Longleftrightarrow$ definido?(n,e.diccString)) \\ $\impluego$ obtener(n,e.diccString)=obtener(n,posEstudianteYHippie(n,r))) $\land$ }


%\disFuncionDeAbsFuncionesAux


\newpage

\disAlgoritmos
%\hspace*{\disSubSubSecMargen}{Texto}
% HACK: SGA 28/05/2011. Para quitar el titulo Algorithm del caption \floatname{algorithm}{}
\floatname{algorithm}{}
% WARNING: SGA 27/05/2011. La opción [H] indica a LaTex que el algoritmo lo queremos AQUI!
% Ver 4.4.1 Placement of Algorithms de algorithms.pdf.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Campus}}{\paramIn{e}{estr}}{$\disFlecha$ res : campus} \Comment{$\Ode{1}$}
  \State res $\gets$ e.campo
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Estudiantes}}{\paramIn{e}{estr}}{$\disFlecha$ res : itConj(nombre)} \Comment{$\Ode{1}$}
  \State res $\gets$ crearIt (e.estudiantes)
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Hippies}}{\paramIn{e}{estr}}{$\disFlecha$ res : itConj(nombre)} \Comment{$\Ode{1}$}
  \State res $\gets$ crearIt (e.hippies)
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Agentes}}{\paramIn{e}{estr}}{$\disFlecha$ res : itConj(agente)} \Comment{$\Ode{1}$}
  \State res $\gets$ claves(e.agentes) 
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$posEstudiantesYHippie}}{\paramIn{e}{estr}, \paramIn{n}{nombre}}{$\disFlecha$ res : posicion} \Comment{$\Ode{\vert N_{m} \vert}$}
    \State res $\gets$ obtener(n,e.posCiviles)
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$posAgente}}{\paramIn{e}{estr} \paramIn{a}{agente}}{$\disFlecha$ res : posicion} \Comment{$\Ode{1}(promedio)$}
    \State res $\gets$ obtener(a,e.agentes).posActual
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$cantSanciones}}{\paramIn{e}{estr}, \paramIn{a}{agente}}{$\disFlecha$ res : nat} \Comment{$\Ode{1}(promedio)$}
    \State res $\gets$ obtener(a,e.agentes).Qsanciones
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$cantHippiesAtrapados}}{\paramIn{e}{estr}, \paramIn{a}{agente}}{$\disFlecha$ res : nat} \Comment{$\Ode{1}(promedio)$}
    \State res $\gets$ obtener(a,e.agentes).premios
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$masVigilante}}{\paramIn{e}{estr}}{$\disFlecha$ res : agente} \Comment{$\Ode{1}$}
    \State res $\gets$ siguiente(e.masVigilante)
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$conMismasSanciones}}{\paramIn{e}{estr} \paramIn{a}{agente}}{$\disFlecha$ res : conj(agente)} \Comment{$\Ode{1}$}
    \State res $\gets$ siguiente(obtener(e.agentes,a).grupoSanciones)
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$conKSanciones}}{\paramIn{e}{estr} \paramIn{k}{nat}}{$\disFlecha$ res : conj(agente)} \Comment{$\Ode{Na}$ la primera vez, luego mientras no haya sanciones $\Ode{log Na}$}
	\If {$\neg$e.hayNuevas} \Comment{$\Ode{1}$}
		 \State var nat i $\gets$ BusquedaBin(e.buscoEnLog, k) \Comment{$\Ode{log Na}$}
		 \State res $\gets$ e.buscoEnLog$_{[i]}$.grupoK \Comment{$\Ode{1}$}
	\Else
		 \State var itLista(datosK) itK $\gets$ crearIt(e.agregoEn1) \Comment{$\Ode{1}$}
		 \While {haySiguiente(it)} \Comment{$\Ode{1}$}
		 	\State buscoEnLog $_{[i]}$ $\gets$ siguiente(itK) \Comment{$\Ode{1}$}
		 	\State avanzar(itK)
		 \EndWhile
		 \State var nat i $\gets$ BusquedaBin (e.buscoEnLog, k) \Comment{$\Ode{log Na}$}
		 \State res $\gets$ e.buscoEnLog$_{[i]}$.grupoK \Comment{$\Ode{1}$}
		 \State e.hayNuevas $\gets$ false \Comment{$\Ode{1}$}
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$ingresarEstudiante}}{\paramInOut {e}{estr}, \paramIn {n}{nombre}, \paramIn {p}{posicion}} \Comment{$\Ode{\mid Nm \mid}$}
\If {esHippizable(e,p)} \Comment{$\Ode{1}$}
		\If {esCapturable(e,p)} \Comment{$\Ode{1}$}
			\State var conj(posicion) v $\gets$ vecinos(e.campus, p) \Comment{$\Ode{1}$}
			\State var itConj(posicion) it $\gets$ crearIt(v) \Comment{$\Ode{1}$}
			\While {haySiguiente(it)}
				\If {e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.queHay == $"$agente"} \Comment{$\Ode{1}$}
					\State recompensar(e, siguiente(it)) \Comment{$\Ode{1}$}
				\EndIf
				\State avanzar(it)
			\EndWhile
		\Else
			\State definir(e.posCiviles, n, p)  \Comment{$\Ode{\mid Nm \mid}$}
			\State var itDicc(nombre, posicion) iterPos $\gets$ definirRapido(e.posRapida,n,p) \Comment{$\Ode{1}$}
			\State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$ true,"hippie",crearIt(), agregarRapido(e.hippies,$<$n,iterPos$>$)$>$ \Comment{$\Ode{1}$}
			\State var conj(posicion) Ps $\gets$ vecinos(e.campus, p) \Comment{$\Ode{1}$}
			\State var itConj(posicion) it $\gets$ crearIt(Ps) \Comment{$\Ode{1}$}
			\While {haySiguiente(it)} 
				\If {esEstudiante(e,siguiente(it)) $\wedge$ esHippizable(e,siguiente(it))} \Comment{$\Ode{1}$}
					\State Hippizar(e, siguiente(it)) \Comment{$\Ode{1}$}
					\If {esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
						\State capturarHippie(e,siguiente(it)) \Comment{$\Ode{\mid Nm \mid}$}
					\EndIf
				\Else
					\If {esEstudiante(e,siguiente(it)) $\wedge$ esCapturable(e, siguiente(it))} \Comment{$\Ode{1}$}
						\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
						\While {haySiguiente(itAg)}  \Comment{$\Ode{1}$}
							\If {esAgente(e, siguiente(itAg))} \Comment{$\Ode{1}$}
								\State sancionar(e,siguiente(itAg)) \Comment{$\Ode{1}$}
							\EndIf
							\State avanzar(itAg)
						\EndWhile
					\Else
						\If {esHippie(e, siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))}  \Comment{$\Ode{1}$}
							\State capturarHippie(e,siguiente(it)) \Comment{$\Ode{\mid Nm \mid}$}
						\EndIf
					\EndIf
				  \EndIf
					\State avanzar(it)
				\EndWhile
			  \EndIf
			\Else
				\State definir(e.posCiviles, n, p)  \Comment{$\Ode{\mid Nm \mid}$}
				\State var itDicc(nombre, posicion) iterPos $\gets$ definirRapido(e.posRapida, n, p)  \Comment{$\Ode{1}$}
				\State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$ true,$"$estudiante",crearIt(), agregarRapido(e.estudiantes,$<$n,iterPos$>$)$>$
				\State var conj(posicion) Ps $\gets$ vecinos(e.campus, p) \Comment{$\Ode{1}$}
				\State var itConj(posicion) it $\gets$ crearIt(ps) \Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]			
				\While {haySiguiente(it)}
					\If {esHippie(e,siguiente(it)) $\wedge$ esEstudiantizable(e,siguiente(it))} \Comment{$\Ode{1}$}
						\State Estudiantizar(e,siguiente(it)) \Comment{$\Ode{1}$}
					\Else
						\If {esEstudiante(e,siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
							\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
							\While {haySiguiente(itAg)}
								\If {esAgente(e,siguiente(itAg))} \Comment{$\Ode{1}$}
									\State Sancionar(e,siguiente(itAg)) \Comment{$\Ode{1}$}
								\EndIf
								\State avanzar(itAg)
							\EndWhile
						\Else
							\If {esHippie(e,siguiente(it) $\wedge$ esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
								\State	capturarHippie(e,siguiente(it))  \Comment{$\Ode{\mid Nm \mid}$}
							\EndIf
						\EndIf
					\EndIf
				\EndWhile
			\EndIf
\textbf{endFunction}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$ingresarHippie}}{\paramInOut{e}{estr} \paramIn{p}{posicion} \paramIn{h:nombre}}{} \Comment{$\Ode{\vert Nm \vert}$}
	\State definir(e.posCiviles, h,p) \Comment{$\Ode{\vert Nm \vert}$}
	\State var itDicc(nombre,posicion) iterPos $\gets$ definirRapido(e.posRapida,h,p) \Comment{$\Ode{1}$}
	\State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$ true, "hippie", crearIt(), agregarRapido(e.hippies,$<$h,iterPos$>$)$>$ \Comment{$\Ode{1}$}
	\State var conj(posicion) Ps $\gets$ vecinos(e.campus,p) \Comment{$\Ode{1}$}
	\State var itConj(posicion) $\gets$ crearIt(ps) \Comment{$\Ode{1}$}
	\If {esCapturable(e,p)} \Comment{$\Ode{1}$}
		\State capturarHippie(e,p) \Comment{$\Ode{\vert Nm \vert}$}
	\Else
		\While {haySiguiente(it)} \Comment{$\Ode{1}$}
			\If {ocupada(e.campus, siguiente(it)) $\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?} \Comment{$\Ode{1}$}
				\State avanzar(it) \Comment{$\Ode{1}$}
			\Else
				\If {esEstudiante(e,siguiente(it)) $\wedge$ esHippizable(e,siguiente(it))} \Comment{$\Ode{1}$}
					\State Hippizar(e, siguiente(it)) \Comment{$\Ode{1}$}
					\If {esCapturable(e,siguiente(it)}	 \Comment{$\Ode{1}$}
						\State capturarHippie(e,siguiente(it))  \Comment{$\Ode{\vert Nm \vert}$}
					\EndIf 
				\Else 
					\If {esEstudiante(e,siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
						\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
						\While {haySiguiente(itAg)} \Comment{$\Ode{1}$}
							\If {esAgente(siguiente(itAg)} \Comment{$\Ode{1}$}
								\State sancionar(e,siguiente(itAg)) \Comment{$\Ode{1}$}
							\EndIf
							\State avanzar(itAg)
						\EndWhile
   					 \EndIf
				\EndIf
			\EndIf
			\State avanzar(it)
		\EndWhile
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$moverEstudiante}}{\paramInOut{e}{estr}, \paramIn{d}{direccion}, \paramIn{s}{estudiante}}{} \Comment{$\Ode{\vert Nm \vert}$}
	\State var posicion actual $\gets$ obtener(e.posCiviles,s)  \Comment{$\Ode{1}$}
	\State var posicion prx $\gets$ proxPosicion(e.campus, d, actual)  \Comment{$\Ode{1}$}
	\If {seFue?(e.campus,actual, prx)}
		\State borrar(e.posCiviles, s) \Comment{$\Ode{\vert Nm \vert}$}
		\State var itConj(datosHoE) dat $\gets$ copia(e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$.hayHoE) \Comment{$\Ode{1}$}
		\State eliminarSiguiente(dat, posActual) \Comment{$\Ode{1}$}
		\State eliminarSiguiente(dat) \Comment{$\Ode{1}$}
		\State e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$ $\gets$ $<$ false, "nada", crearIt(), crearIt() $>$ \Comment{$\Ode{1}$}
	\Else
		\State var itConj(datosHoE) iterAHOI $\gets$ copia(e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$.hayHoE) \Comment{$\Ode{1}$}
		\State eliminarSiguiente(siguiente(iterAHOI).posActual) \Comment{$\Ode{1}$}
		\State siguiente(iterAHOI).posActual $\gets$ definirRapido(e.posRapida,s,prx) \Comment{$\Ode{1}$}
		\State e.quienOcupa$_{[prx.X]}$ $_{[prx.Y]}$ $\gets$ $<$true, $"$estudiante$"$, crearIt(), iterAHOI$>$ \Comment{$\Ode{1}$}
		\State e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$ $\gets$ $<$false, "nada", crearIt(), crearIt()$>$ \Comment{$\Ode{1}$}
		\State definir(e.posCiviles, s, prx) \COmment{$\Ode{\vert Nm \vert}$}
		\State var conj(posicion) vc $\gets$ vecinos(e.campus, prx) \Comment{$\Ode{1}$}
		\State var itConj(posicion) it $\gets$ crearIt(vc) \Comment{$\Ode{1}$}
		
		\If {esHippizable(e,prx)} \Comment{$\Ode{1}$}
			\State hippizar(e, prx) \Comment{$\Ode{1}$}
			\While {haySiguiente(it} \Comment{$\Ode{1}$}
				\If {ocupada(e.campus, siguiente(it)) $\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?}
					\State avanzar(it)
				\Else \If {esEstudiante(e,siguiente(it)) $\wedge$ esHippizable(e,siguiente(it))} \Comment{$\Ode{1}$}
						 \State Hippizar(e, siguiente(it))  \Comment{$\Ode{1}$}
						 \If {esCapturable(e, siguiente(it))}  \Comment{$\Ode{1}$}
						 	\State capturarHippie(e,siguiente(it))  \Comment{$\Ode{\vert Nm \vert}$}
						 \EndIf
					  \Else \If {esEstudiante(e,siguiente(it) $\wedge$ esCapturable(e,siguiente(it)} \Comment{$\Ode{1}$}
					  			\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
					  			\While {haySiguiente(itAg)} \Comment{$\Ode{1}$}
					  				\If {esAgente(e,siguiente(itAg)} \Comment{$\Ode{1}$}
					  					\State sancionar(e,siguiente(itAg)) \Comment{$\Ode{1}$}
					  				\EndIf
					  			\State avanzar(itAg)
					  			\EndWhile
					  		\Else
					  			\If {esHippie(e,siguiente(it)) $\wedge$ esCapturable(s,siguiente(it))} \Comment{$\Ode{1}$}
					  				\State capturarHippie(e,siguiente(it))  \Comment{$\Ode{\vert Nm \vert}$}
					  			\EndIf	
					  		\EndIf
					  	\EndIf
					\EndIf
			\EndWhile
		\Else
			\While {haySiguiente(it)}
			\If {ocupada(e.campus, siguiente(it))$\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?} \Comment{$\Ode{1}$}
					\State avanzar(it)
				\Else
					\If {esHippie(e, siguiente(it)) $\wedge$ esEstudiantizable(e,siguiente(it))} \Comment{$\Ode{1}$}
						\State Estudiantizar(e, siguiente(it)) \Comment{$\Ode{1}$}
					\Else
						\If {esEstudiante(e,siguiente(it)) $\wedge$ esCapturable(e, siguiente(it))} \Comment{$\Ode{1}$}
							\State var itConj(posicion) itAg2 $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
							\While {haySiguiente(itAg2)} \Comment{$\Ode{1}$}
								\If {esAgente(e,siguiente(itAg2))} \Comment{$\Ode{1}$}
									\State sancionar(e,siguiente(itAg2)) \Comment{$\Ode{1}$}
								\EndIf
								\State avanzar(itAg2)
							\EndWhile
							\newpage
						\Else
							\If {esHippie(e, siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
								\State capturarHippie(e, siguiente(it))  \Comment{$\Ode{\vert Nm \vert}$}
							\EndIf
						\EndIf
					\EndIf
				\EndIf
				\State avanzar(it)
			\EndWhile
		\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$moverAgente}}{\paramInOut{e}{estr} \paramIn{a}{agente}}{} \Comment{$\Ode{\vert Nm \vert}+\Ode{log Na}+\Ode{Ne}$}
    \State var nat j $\gets$ BusquedaBin(e.AgentesLog,a) \Comment{$\Ode{log Na}$}
    \State var posicion actual $\gets$ e.AgentesLog$_{[j]}$ \Comment{$\Ode{1}$}
    \State var direccion d $\gets$ proxPosicionA(e,a) \Comment{$\Ode{Ne}$}
    \State var posicion prx $\gets$ proxPosicion(e.campus, d, actual) \Comment{$\Ode{1}$}
    \State var datosAg datAux $\gets$ obtener(e.agentes, a) \Comment{$\Ode{1}$}
    \State datAux.posActual $\gets$ prx \Comment{$\Ode{1}$}
    \State var itDicc(placa,datosAg) itA $\gets$ copia(e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$.hayCana) \Comment{$\Ode{1}$}
    \State e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$ $\gets$ $<$false, "nadie", crearIt(), crearIt()$>$ \Comment{$\Ode{1}$}
    \State e.quienOcupa$_{[prx.X]}$ $_{[prx.Y]}$ $\gets$ $<$true, $"$agente", itA, crearIt()$>$ \Comment{$\Ode{1}$}
    \State var itConj(posicion) $\gets$ crearIt(vecinos(e.campus, prx)) \Comment{$\Ode{1}$}
    \While {haySiguiente(it)} \Comment{$\Ode{1}$}
    	\If {ocupada(e.campus, siguiente(it)) $\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?}
    		\State avanzar(it)
    	\Else
    		\If {esEstudiante(e, siguiente(it)) $\wedge$ esCapturable(e, siguiente(it))} \Comment{$\Ode{1}$}
    			\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
    			\While {haySiguiente(itAg)}  \Comment{$\Ode{1}$}
    				\If {esAgente(e,siguiente(itAg))}  \Comment{$\Ode{1}$}
    					\State sancionar(e, siguiente(itAg))  \Comment{$\Ode{1}$}
    				\EndIf
	    			\State avanzar(itAg)
    			\EndWhile
    		\Else
    			\If {esHippie(e,siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))}  \Comment{$\Ode{1}$}
    				\State capturarHippie(e, siguiente(it))  \Comment $\Ode{\vert Nm \vert}$
    			\EndIf
    		\EndIf
    	\EndIf	
    	\State avanzar(it)
    \EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$moverHippie}}{\paramInOut{e}{estr} \paramIn{h}{nombre}}{} \Comment{$\Ode{\vert Nm \vert}$ + $\Ode{Ne}$}
	\State var posicion actual $\gets$ obtener(e.posCiviles, h) \Comment{$\Ode{\vert Nm \vert}$}
	\State var direccion d $\gets$ proxPosicionH(e,h) \Comment{$\Ode{Ne}$}
	\State var posicion prx $\gets$ proxPosicion(e.campus, d, obtener(e.posCiviles,h)) \Comment{$1$}
	\State definir(e.posCiviles, h, prx) \Comment{$\Ode{\vert Nm \vert}$}
	\State var itConj(nombre) itR $\gets$ e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$.hayHoe \Comment{$\Ode{1}$}
	\State eliminarSiguiente(siguiente(itR).posActual) \Comment{$\Ode{1}$}
	\State siguiente(itR).posActual $\gets$ definirRapido(e.posRapida, h, prx) \Comment{$\Ode{1}$}
	\State e.quienOcupa$_{[prx.X]}$ $_{[prx.Y]}$ $\gets$ $<$true, "hippie", crearIt(), itR$>$ \Comment{$\Ode{1}$}
	\State e.quienOcupa$_{[actual.X]}$ $_{[actual.Y]}$ $\gets$ $<$false, "nadie", crearIt(), crearIt()$>$ \Comment{$\Ode{1}$}
	\While {haySiguiente(it)}
		\If {ocupada(e.campus, siguiente(it)) $\vee$ $\neg$e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?} \Comment{$\Ode{1}$}
			\State avanzar(it)
		\Else
			\If {esEstudiante(e,siguiente(it)) $\wedge$ esHippizable(e, siguiente(it))} \Comment{$\Ode{1}$}
				\State hippizar(e, siguiente(it)) \Comment{$\Ode{1}$}
						\If {esCapturable(e,siguiente(it)}
							\State capturarHippie(e,siguiente(it)) \Comment{$\Ode{\vert Nm \vert}$}
						\EndIf
			\Else
				 \If {esEstudiante(e, siguiente(it)) $\wedge$ esCapturable(e, siguiente(it))} \Comment{$\Ode{1}$}
				 	\State var itConj(posicion) itAg $\gets$ vecinos(e.campus, siguiente(it)) \Comment{$\Ode{1}$}
				 	\While {haySiguiente(itAg)}
				 		\If {esAgente(e,siguiente(itAg))} 
				 			\State sancionar(e, siguiente(itAg))
				 		\EndIf
				 		\State avanzar(itAg)
				 	\EndWhile
				 \Else
				 	\If {esHippie(e,siguiente(it)) $\wedge$ esCapturable(e,siguiente(it))} \Comment{$\Ode{1}$}
				 		\State capturarHippie(e,siguiente(it)) \Comment{$\Ode{\vert Nm \vert}$}
				 	\EndIf
				 \EndIf
			\EndIf
		\EndIf
		\State avanzar(it)
	\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}



\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$esEstudiante}}{\paramIn{e}{estr} \paramIn{p}{posicion}}{$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
    \State res $\gets$ e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.queHay $==$ $"$estudiante"
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$esHippie}}{\paramIn{e}{estr} \paramIn{p}{posicion}}{$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
    \State res $\gets$ e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.queHay $==$ "hippie"
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$esAgente}}{\paramIn{e}{estr} \paramIn{p}{posicion}}{$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
    \State res $\gets$ e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.queHay $==$ $"$agente"
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Estudiantizar}}{\paramInOut{e}{estr} \paramIn{p}{posicion}}{} \Comment{$\Ode{1}$}
    \State var datosHoE dat $\gets$ $<$Siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoE).ID, Siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoe).posActual$>$ \Comment{$\Ode{1}$}
    \State eliminarSiguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoe) \Comment{$\Ode{1}$}
    \State var itConj(nombre) it $\gets$ agregarRapido(e.estudiantes, dat) \Comment{$\Ode{1}$}
    \State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$true, $"$estudiante", crearIt(), it$>$ \Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$Hippizar}}{\paramInOut{e}{estr} \paramIn{p}{posicion}}{} \Comment{$\Ode{1}$}
    \State var datosHoE dat $\gets$ $<$Siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoE).ID, Siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoe).posActual$>$ \Comment{$\Ode{1}$}
    \State eliminarSiguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoe) \Comment{$\Ode{1}$}
    \State var itConj(nombre) it $\gets$ agregarRapido(e.hippies, dat) \Comment{$\Ode{1}$}
    \State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$true, "hippie", crearIt(), it$>$ \Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$esCapturable}}{\paramIn{e}{estr} \paramIn{p}{posicion}}{$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
    \State var itConj(posicion) it $\gets$ crearIt(vecinos(e.campus, p)) \Comment{$\Ode{1}$}        	\State var nat Contador $\gets$ 0 \Comment{$\Ode{1}$}
    \State bool hayGuardia $\gets$ false \Comment{$\Ode{1}$}
	\While {haySiguiente(it)}
		\If {e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.ocupada?} \Comment{$\Ode{1}$}
			\State contador$+$ $+$ \Comment{$\Ode{1}$}
		\EndIf
		\If {e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.quienOcupa== $"$agente" } \Comment{$\Ode{1}$}
   			\State  hayGuardia $\gets$ true \Comment{$\Ode{1}$}
   		\EndIF
   		\State avanzar(it)
   	\EndWhile
   	\State res $\gets$ contador == 4 $\wedge$ hayGuardia \Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$esHippizable}}{\paramInOut{e}{estr} \paramIn{p}{posicion}}{$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
    \State var itConj(posicion) it $\gets$ crearIt(vecinos(e.campus, p)) \Comment{$\Ode{1}$}        	\State var nat Contador $\gets$ 0 \Comment{$\Ode{1}$}
    \While {haySiguiente(it)} \Comment{$\Ode{1}$}
    	\If {e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.quienOcupa == "hippie"} \Comment{$\Ode{1}$}
    		\State contador $+$ $+$ \Comment{$\Ode{1}$}
    	\EndIf
    	\State avanzar(it)
     \EndWhile
    \State res $\gets$ contador $\geqslant$ 2 \Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$capturarHippie}}{\paramInOut{e}{estr} \paramIn{p}{posicion}}{} \Comment{$\Ode{\vert Nm \vert}$}
    \State var nombre n $\gets$ siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoE).ID \Comment{$\Ode{1}$}
    \State eliminarSiguiente(siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoE).posActual) \Comment{$\Ode{1}$}
    \State eliminarSiguiente(siguiente(e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$.hayHoE) \Comment{$\Ode{1}$}
    \State borrar(n, e.posCiviles) \Comment{$\Ode{\vert Nm \vert}$}
	\State e.quienOcupa$_{[p.X]}$ $_{[p.Y]}$ $\gets$ $<$false, nadie, crearIt(), crearIt() $>$ \Comment{$\Ode{1}$}
	 \While {haySiguiente(it)} \Comment{$\Ode{1}$}
    	\If {e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.quienOcupa == $"$agente"} \Comment{$\Ode{1}$}
    		\State recompensar(e, siguiente(it)) \Comment{$\Ode{1}$}
    	\EndIf
    	\State avanzar(it)
     \EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$todasOcupadas}}{\paramIn{e}{estr}, \paramIn{p}{conj(posicion)}}{$\disFlechas$ res:bool} \Comment{$\Ode{1}$}
	\State var itConj(posicion) it $\gets$ crearIt(p) \Comment{$\Ode{1}$}
	\State var contador $\gets$ 0 \Comment{$\Ode{1}$}
	\While {haySiguiente(it)}
		\If {e.quienOcupa$_{[siguiente(it).X]}$ $_{[siguiente(it).Y]}$.ocupada?} \Comment{$\Ode{1}$}
		    \State contador $+$ $+$ \Comment{$\Ode{1}$}
		\EndIf
	\EndWhile
	\State res $\gets$ contador == 4
\EndFunction
\end{algorithmic}
\end{algorithm}	
	

\begin{algorithmic}[H]
\begin{algorithm}
\Function{\textsc{$i$Recompensar}}{\paramInOut{e}{estr}, \paramIn{a}{posicion}}{} \Comment{$\Ode{1}$}
	\State var placa p $\gets$ siguienteClave(quienOcupa$_{[a.X]}$ $_{[a.Y]}$.hayCana \Comment{$\Ode{1}$}
	\State var datosAgente dat $\gets$ obtener(e.agentes,p) \Comment{$\Ode{1}$}
	\State dat.premios $\gets$ dat.premios$+$1 \Comment{$\Ode{1}$}
	\If {dat.premios $>$ obtener(e.agentes, siguienteClave(e.masVigilante)).premios} \Comment{$\Ode{1}$}
		\State e.masVigilante $\gets$ quienOcupa$_{[a.X]}$ $_{[a.Y]}$.hayCana \Comment{$\Ode{1}$}
	\Else
		\If {dat.premios $==$ obtener(e.agentes, siuienteClave(e.masVigilante)).premios} \Comment{$\Ode{1}$}
			\If {p $<$ siguienteClave(e.masVigilante))} \Comment{$\Ode{1}$}
				\State e.masVigilante $\gets$ quienOcupa$_{[a.X]}$ $_{[a.Y]}$.hayCana \Comment{$\Ode{1}$}
			\EndIf
		\EndIf
	\EndIf
\EndFunction
\end{algorithm}
\end{algorithmic}

\begin{algorithmic}[H]
\begin{algorithm}
\Function{\textsc{$i$Sancionar}}{\paramInOut{e}{estr}, \paramIn{a}{posicion}}{} \Comment{$\Ode{1}$}
	\State var placa p $\gets$ siguienteClave(quienOcupa$_{[a.X]}$ $_{[a.Y]}$.hayCana \Comment{$\Ode{1}$}
	\State var datosAgente dat $\gets$ obtener(e.agentes,p) \Comment{$\Ode{1}$}
	\State dat.Qsanciones $\gets$ dat.Qsanciones$+$1 \Comment{$\Ode{1}$}
	\State eliminarSiguiente(dat.grupoSanciones)  \Comment{$\Ode{1}$}
	\State avanzar(dat.verK)  \Comment{$\Ode{1}$}
	\State e.hayNuevas $\gets$ true  \Comment{$\Ode{1}$}
	\If {Siguiente(dat.verK).K == dat.Qsanciones} \Comment{$\Ode{1}$}
		\State dat.grupoSanciones $\gets$ Agregar(siguiente(dat.verK).grupoK, p)  \Comment{$\Ode{1}$}
	\Else
		\State dat.grupoSanciones $\gets$ AgregarComoAnterior(dat.verK, $<$dat.Qsanciones,Agregar(Vacio(),p)$>$) \Comment{$\Ode{1}$}
	\EndIf
\EndFunction
\end{algorithm}
\end{algorithmic}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$ProxPosicionH}}{\paramInOut{e}{estr} \paramIn{h}{nombre}}{} \Comment{$\Ode{N_{e}}$}
	\State var itConj(datosHoE) it$\gets$ crearIt(e.estudiantes) \Comment{$\Ode{1}$}
	\State var posicion menorD $\gets$ obtener(e.posRapida,h)	\Comment{$\Ode{N_{e}}$}
	\State var direccion direcc \Comment{$\Ode{1}$}
	\If {($\neg$ haySiguiente(it)) } \Comment{$\Ode{1}$}
		\If { (menorD.Y $\leq$ e.campus.filas/2) } \Comment{$\Ode{1}$}
			\If { ($\neg$ ocupadaD(e,p,abajo)) } \Comment{$\Ode{1}$}
				\State res$\gets$Abajo \Else \Comment{$\Ode{1}$}
				\If { ($\neg$ ocupadaD(e,p,derecha)) } \Comment{$\Ode{1}$}
					\State res$\gets$Derecha \Else \Comment{$\Ode{1}$}
					\If { ($\neg$ ocupadaD(e,p,izquierda)) } \Comment{$\Ode{1}$}
						\State res$\gets$izquierda \Else \Comment{$\Ode{1}$}
						\State res$\gets$arriba \Comment{$\Ode{1}$}
					\EndIf
				\EndIf
			\EndIf
		\Else
			\If {($\neg$ ocupadaD(e,p,Arriba)) } \Comment{$\Ode{1}$}
				\State res$\gets$Arriba \Else \Comment{$\Ode{1}$}
				\If {($\neg$ ocupadaD(e,p,derecha)) } \Comment{$\Ode{1}$}
					\State res$\gets$Derecha \Else \Comment{$\Ode{1}$}
					\If {($\neg$ ocupadaD(e,p,izquierda)) } \Comment{$\Ode{1}$}
						\State res$\gets$izquierda \Else \Comment{$\Ode{1}$}
						\State res$\gets$Abajo \Comment{$\Ode{1}$}
					\EndIf
				\EndIf
			\EndIf
		\EndIf
	\Else
		\State menorD$\gets$SiguienteSignificado(siguiente(it).posActual) \Comment{$\Ode{1}$}
		\State var posicion otraPos \Comment{$\Ode{1}$}
		\While{haySiguiente(it)} \Comment{$\Ode{\longitud{N_{e}}}$}
			\State otraPos$\gets$SiguienteSignificado(siguiente(it).posActual) \Comment{$\Ode{1}$}
			\If {(distancia(e,p,otraPos) $<$ distancia(e,p,menorD)) } \Comment{$\Ode{1}$}
				\State menorD$\gets$otraPos \Comment{$\Ode{1}$}
			\EndIf
		\EndWhile
		\State res$\gets$VecinoMasCercanoA(e,p,menorD) \Comment{$\Ode{1}$}
	\EndIf	
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$ProxPosicionA}}{\paramInOut{e}{estr} \paramIn{a}{placa}}{} \Comment{$\Ode{N_{h}}$}
	\State var itConj(datosHoe) it $\gets$  crearIt(e.hippies) \Comment{$\Ode{1}$}
	\State var posicion menorD  $\gets$  obtener(e.posRapida,a) \Comment{$\Ode{N_{h}}$}
	\State var direccion direcc \Comment{$\Ode{1}$}
	\If{ ($\neg$ haySiguiente(it)) } \Comment{$\Ode{1}$}
		\If{ (menorD.Y $\leq$ e.campus.filas/2) } \Comment{$\Ode{1}$}
			\If{ ($\neg$ ocupadaD(e,p,abajo)) } \Comment{$\Ode{1}$}
				\State res $\gets$ Abajo \Else \Comment{$\Ode{1}$}
				\If{ ($\neg$ ocupadaD(e,p,derecha)) } \Comment{$\Ode{1}$}
					\State res $\gets$ Derecha \Else \Comment{$\Ode{1}$}
					\If{ ($\neg$ ocupadaD(e,p,izquierda)) } \Comment{$\Ode{1}$}
						\State res $\gets$ izquierda \Else \Comment{$\Ode{1}$}
						\State res $\gets$ arriba \Comment{$\Ode{1}$}
					\EndIf
				\EndIf
			\EndIf
		\Else 
			\If{ ($\neg$ ocupadaD(e,p,Arriba)) } \Comment{$\Ode{1}$}
				\State res $\gets$ Arriba \Else \Comment{$\Ode{1}$}
				\If{ ($\neg$ ocupadaD(e,p,derecha)) } \Comment{$\Ode{1}$}
					\State res $\gets$ Derecha \Else \Comment{$\Ode{1}$}
					\If{ ($\neg$ ocupadaD(e,p,izquierda)) } \Comment{$\Ode{1}$}
						\State res $\gets$ izquierda \Else \Comment{$\Ode{1}$}
						\State res $\gets$ Abajo \Comment{$\Ode{1}$}
					\EndIf
				\EndIf
			\EndIf
		\EndIf
	\Else
		\State menorD $\gets$ siguiente(it) \Comment{$\Ode{1}$}
		\State var posicion otraPos \Comment{$\Ode{1}$}
		\While{haySiguiente(it)} \Comment{$\Ode{\longitud{N_{h}}}$}
			\State otraPos $\gets$ SiguienteSignificado(siguiente(it).posActual) \Comment{$\Ode{1}$}
			\If{(distancia(e,p,otraPos)$<$distancia(e,p,menorD)) } \Comment{$\Ode{1}$}
				\State menorD $\gets$ otraPos \Comment{$\Ode{1}$}
			\EndIf
		\EndWhile
		\State res $\gets$ VecinoMasCercanoA(e,p,menorD)	 \Comment{$\Ode{1}$}
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$VecinoMasCercano}}{\paramIn{e}{estr} \paramIn{p}{posicion} \paramIn{p2}{posicion} } {$\disFlecha$ res : direccion} \Comment{$\Ode{1}$}
	\State var conj(posicion) Ps $\gets$ vecinos(e.campus, p) \Comment{$\Ode{1}$}
	\State var itConj(posicion) it $\gets$ crearIt(Ps) \Comment{$\Ode{1}$}
	\State var posicion destino$\gets$ siguiente(it) \Comment{$\Ode{1}$}
	\While{haySiguiente(it)} \Comment{$\Ode{1}$}
		\If{($\neg$e.quienOcupa[siguiente(it).X][siguiente(it).Y].ocupada?)} \Comment{$\Ode{1}$}
			\If{(distancia(e,p,siguiente(it))$<$distancia(e,p,destino))} \Comment{$\Ode{1}$}
				\State destino$\gets$ siguiente(it) \Comment{$\Ode{1}$}
			\EndIf
		\EndIf
		\State avanzar(it) \Comment{$\Ode{1}$}
	\EndWhile
	\If{(destino.X$\neq$p.X) } \Comment{$\Ode{1}$}
		\If{(destino.y$>$p.Y) } \Comment{$\Ode{1}$}
			\State res$\gets$ Arriba \Else \Comment{$\Ode{1}$}
			\State res$\gets$ Abajo \Comment{$\Ode{1}$}
		\EndIf
	\Else
		\If{(destino.x$>$p.x) } \Comment{$\Ode{1}$}
			\State res$\gets$ Derecha \Else \Comment{$\Ode{1}$}
			\State res$\gets$ Izquierda \Comment{$\Ode{1}$}
		\EndIf
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$SeFue}}{\paramIn{e}{estr} \paramIn{p}{posicion} \paramIn{destino}{posicion} } {$\disFlecha$ res : bool} \Comment{$\Ode{1}$}

	\State res $\gets$ (p.Y$==$e.campus.alto $-$1 $\wedge$ destino.y$==$e.campus.alto) $\vee$(p.Y$==$0 && destino.y$==-$1) \Comment{$\Ode{1}$}
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$BusquedaBin}}{\paramIn{v}{vector(datosK)} \paramIn{obj}{nat}} {$\disFlecha$ res : nat} \Comment{$\Ode{log_{2}(longitud(v))}$}
	\State var int i$\gets$ 0 \Comment{$\Ode{1}$}
	\State var int d$\gets$ longitud(v)-1 \Comment{$\Ode{1}$}
	\While{(i $+1<$ d)}\Comment{$\Ode{log_{2}(longitud(v))}$}
		\State var int m$\gets$  (i$+$d)$/2$ \Comment{$\Ode{1}$}
		\If{(v[m].k$<$obj)} \Comment{$\Ode{1}$}
			\State i$\gets$ m \Else \Comment{$\Ode{1}$}
			\State d$\gets$ m \Comment{$\Ode{1}$}
		\EndIf
	\EndWhile
	\If{(v[i].k$==$obj)} \Comment{$\Ode{1}$}
		\State res$\gets$ i \Else \Comment{$\Ode{1}$}
		\State res$\gets$ d \Comment{$\Ode{1}$}
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function {\textsc{$i$ocupadaD}}{\paramIn{e}{rastr} \paramIn{p}{posicion} \paramIn{dir}{direccion}} {$\disFlecha$ res : bool} \Comment{$\Ode{1}$}
\If{dir$==$ `` Arriba"}\Comment{$\Ode{1}$}
	\State res$\gets$e.quienOcupa[p.X][p.Y $+1$].ocupada? \Else \Comment{$\Ode{1}$}
	\If{dir$==$ `` Abajo"}\Comment{$\Ode{1}$}
		\State res$\gets$e.quienOcupa[p.X][p.Y $-1$].ocupada? \Else \Comment{$\Ode{1}$}
		\If{dir$==$ `` izquierda"} \Comment{$\Ode{1}$}
			\State res$\gets$e.quienOcupa[p.X$-1$][p.Y].ocupada? \Else \Comment{$\Ode{1}$}
			\State res$\gets$e.quienOcupa[p.X$+1$][p.Y].ocupada? \Comment{$\Ode{1}$}
		\EndIf
	\EndIf
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}